var _ = require('underscore');
var assert = require('assert');
var fs = require('fs');
var temp = require('temp');
var url = require('url');
var util = require('util');
var async = require('async');

var Cassandra = require('oae-util/lib/cassandra');
var TestsUtil = require('oae-tests');
var RestAPI = require('oae-rest');
var TaskQueue = require('oae-util/lib/taskqueue');
var PreviewConstants = require('oae-preview-processor/lib/constants');
var UserDAO = require('../lib/internal/dao/users.js');

describe('Loodle', function () {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousRestContext = null;
    // Rest contexts that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;
    var gtAdminRestContext = null;
    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;

    /**
     * Create a number of users that will be used inside of a test
     * @param  {Function(contexts)}  callback           Standard callback function
     * @param  {Object}              callback.contexts  Object where the keys are identifiers for the created users and the values are an
     *                                                  object with a user key containing the user object for the created user and a restContext key
     *                                                  containing the REST Context for that user
     */
    var setUpUsers = function(callback) {
        var contexts = {};
        var createUser = function(identifier, visibility, displayName) {
            var userId = TestsUtil.generateTestUserId(identifier);
            var email = TestsUtil.generateTestEmailAddress(null, global.oaeTests.tenants.cam.emailDomain);
            RestAPI.User.createUser(camAdminRestContext, userId, 'password', displayName, email, {'visibility' : visibility}, function(err, createdUser) {
                if (err) {
                    assert.fail('Could not create test user');
                }
                contexts[identifier] = {
                    'user': createdUser,
                    'restContext': TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, userId, 'password')
                };
                if (_.keys(contexts).length === 7) {
                    callback(contexts);
                }
            });
        };

        createUser('nicolaas', 'public', 'Nicolaas Matthijs');
        createUser('simon', 'loggedin', 'Simon Gaeremynck');
        createUser('bert', 'private', 'Bert Pareyn');
        createUser('branden', 'private', 'Branden Visser');
        createUser('anthony', 'public', 'Anthony Whyte');
        createUser('stuart', 'public', 'Stuart Freeman');
        createUser('ian', 'public', 'Ian Dolphin');
    };

    /**
     * Function that will fill up the anonymous and tenant admin REST context
     */
    before(function (callback) {
        // Fill up anonymous rest context
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);
        // Fill up tenant admin rest contexts
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);
        // Fill up global admin rest context
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();

        // Log in the tenant admin so his cookie jar is set up appropriately. This is because TestsUtil.generateTestUsers
        // will concurrently try and create users, which causes race conditions when trying to authenticate the rest
        // context.
        RestAPI.User.getMe(camAdminRestContext, function(err, meObj) {
            assert.ok(!err);

            // Unbind the current handler, if any
            TaskQueue.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                assert.ok(!err);

                /*!
                 * Task handler that will just drain the queue.
                 *
                 * @see MQ#bind
                 */
                var _handleTaskDrain = function(data, mqCallback) {
                    // Simply callback, which acknowledges the message without doing anything.
                    mqCallback();
                };

                // Drain the queue
                TaskQueue.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, _handleTaskDrain, null, function(err) {
                    assert.ok(!err);
                    callback();
                });
            });
        });
    });

    /**
     * Function that will clean up any files that we have lingering around.
     */
    after(function () {
        temp.cleanup();
    });

    /**
     * Get loodle id
     *
     * @param contentId
     * @param callback
     */
    var getLoodleId = function (contentId, callback) {

        var query = 'SELECT "loodleId" FROM "LoodleIdByContent" WHERE "contentId" = ?';
        var parameters = [
            contentId
        ];

        Cassandra.runQuery(query, parameters, function (err, result) {
            if (err)
                return callback(err);

            if (result.length === 0)
                return callback(null, false);

            return callback(null, Cassandra.rowToHash(result[0]).loodleId);
        });

    };

    describe('create', function () {

        /**
         * Get user token
         *
         * @param userId
         * @param callback
         */
        var getUserToken = function (userId, callback) {

            var query = 'SELECT "token" FROM "LoodleTokenByUser" where "userId" = ?';
            var parameters = [ userId ];

            Cassandra.runQuery(query, parameters, function (err, result) {

                if (err) return callback(err);
                if (result.length === 0) return callback(null, false);

                return callback(null, Cassandra.rowToHash(result[0]).token);
            });

        };

        it('should create a loodle in the loodle application', function (callback) {
            setUpUsers(function (contexts) {
                RestAPI.Loodle.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [contexts['branden'].user.id], [], [], function (err, data) {
                    assert.equal(err, null);
                    assert.equal(data.displayName, 'Mon super loodle');
                    assert.equal(data.description, 'Test');
                    assert.equal(data.visibility, 'private');
                    assert.equal(data.resourceSubType, 'doodle');

                    return callback();
                });
            });
        });

        it('should create a mirror account in the loodle application for the user if he/she does not have one yet', function (callback) {
            setUpUsers(function (contexts) {
                RestAPI.Loodle.createLoodle(contexts['bert'].restContext, 'Mon super loodle', 'Test', 'private', [contexts['bert'].user.id], [], [], function (err, data) {

                    // Check if an access token is associated with the user id, if it is it means a mirror account has
                    // bean created in the loodle application
                    getUserToken(contexts['bert'].user.id, function (err, token) {
                        assert.equal(err, null);
                        assert.notEqual(token, false);

                        return callback();
                    });

                });
            });
        });

        it('should save in db the matching contentId - loodleId', function (callback) {
            setUpUsers(function (contexts) {
                RestAPI.Loodle.createLoodle(contexts['bert'].restContext, 'Mon super loodle', 'Test', 'private', [contexts['bert'].user.id], [], [], function (err, data) {

                    // Check if there is a loodle id associated with the content id received, if it is it means a loodle
                    // has bean created in the loodle application
                    getLoodleId(data.id, function (err, loodleId) {
                        assert.equal(err, null);
                        assert.notEqual(loodleId, false);

                        return callback();
                    });
                });
            });
        });

        it('should add the optional additional members to the loodle', function (callback) {
            setUpUsers(function (contexts) {

                RestAPI.Loodle.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], [], function (err, data) {
                    assert.equal(err, null);

                    getLoodleId(data.id, function (err, loodleId) {
                        assert.equal(err, null);

                        RestAPI.Loodle.getLoodle(contexts['branden'].restContext, loodleId, function (err, data) {
                            assert.equal(err, null);
                            data.users.forEach(function (element, index) {
                                if (!(element.first_name === 'Branden') && !(element.first_name === 'Simon') && !(element.first_name === 'Stuart')) {
                                    assert(false, 'Users not found in loodle data');
                                }
                            });

                            return callback();
                        });
                    });

                });
            });
        });
    });

    describe('getLoodle', function () {

        // Creation of a loodle to play with
        before(function (callback) {
            setUpUsers(function (contexts) {

                contextsData = contexts;

                RestAPI.Loodle.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    getLoodleId(data.id, function (err, data) {
                        if (err) return callback(err);
                        loodleId = data;

                        return callback();
                    });

                });

            });
        });

        var contextsData,
            loodleId;

        it('should get the loodle data', function (callback) {

            RestAPI.Loodle.getLoodle(contextsData['branden'].restContext, loodleId, function (err, data) {

                assert.equal(err, null);
                assert.equal(data.name, 'Mon super loodle');
                assert.equal(data.description, 'Test');
                assert.equal(data.category, 'private');
                assert.equal(data.users[0].first_name, 'Branden');

                return callback();
            });

        });

    });

    describe('delete', function () {

        var contextsData,
            contentId;

        // Create a loodle to play with
        before(function (callback) {

            setUpUsers(function (contexts) {

                contextsData = contexts;

                RestAPI.Loodle.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);
                    contentId = data.id;

                    return callback();
                });

            });

        });

        it('should delete the loodle in the loodle application', function (callback) {

            RestAPI.Loodle.deleteLoodle(contextsData['branden'].restContext, contentId, function (err, data) {
                assert.equal(err, null);
                assert.equal(data, 'OK');

                return callback();
            });

        });
    });

    describe('updateMembers', function () {

        var contextsData,
            contentId;

        // Create a loodle to play with
        before(function (callback) {

            setUpUsers(function (contexts) {

                contextsData = contexts;

                RestAPI.Loodle.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);
                    contentId = data.id;

                    return callback();
                });

            });

        });

        it('should add the user to the loodle if that was the specified update', function (callback) {

            var changes = {};
            changes[contextsData['simon'].user.id] = 'viewer';
            changes[contextsData['stuart'].user.id] = 'manager';

            RestAPI.Loodle.updateMembers(contextsData['branden'].restContext, contentId, changes, function (err, data) {

                getLoodleId(contentId, function (err, loodleId) {
                    assert.equal(err, null);

                    RestAPI.Loodle.getLoodle(contextsData['branden'].restContext, loodleId, function (err, data) {
                        assert.equal(err, null);
                        data.users.forEach(function (element, index) {
                            if (!(element.first_name === 'Branden') && !(element.first_name === 'Simon') && !(element.first_name === 'Stuart')) {
                                assert(false, 'Users not found in loodle data');
                            }
                        });

                        return callback();
                    });

                });

            });

        });

        it('should remove the user if thas was the specified update', function (callback) {

            var changes = {};
            changes[contextsData['simon'].user.id] = false;

            RestAPI.Loodle.updateMembers(contextsData['branden'].restContext, contentId, changes, function (err, data) {

                getLoodleId(contentId, function (err, loodleId) {
                    assert.equal(err, null);

                    RestAPI.Loodle.getLoodle(contextsData['branden'].restContext, loodleId, function (err, data) {

                        var stillInLoodle = false;

                        assert.equal(err, null);
                        data.users.forEach(function (element, index) {
                            if (element.first_name === 'Simon') {
                                stillInLoodle = true;
                            }
                        });

                        if (stillInLoodle) assert(false, 'User still in loodle');

                        return callback();
                    });

                });

            });

        });

        it('should create a mirror account in the loodle application for the specified users if they do no have one yet', function (callback) {

            // We add a user that is completely unknown for the loodle application,
            // If the update is working correctly, it means a mirror account has been created for him/her
            var changes = {};
            changes[contextsData['anthony'].user.id] = 'viewer';

            RestAPI.Loodle.updateMembers(contextsData['branden'].restContext, contentId, changes, function (err, data) {

                getLoodleId(contentId, function (err, loodleId) {
                    assert.equal(err, null);

                    RestAPI.Loodle.getLoodle(contextsData['branden'].restContext, loodleId, function (err, data) {
                        assert.equal(err, null);
                        data.users.forEach(function (element, index) {
                            if (!(element.first_name === 'Branden') && !(element.first_name === 'Simon') && !(element.first_name === 'Stuart') && !(element.first_name === 'Anthony')) {
                                assert(false, 'Users not found in loodle data');
                            }
                        });

                        return callback();
                    });
                });
            });

        });

    });

    describe('addSchedule', function () {

        var contextsData,
            loodleId;

        // Create a loodle to play with
        before(function (callback) {

            setUpUsers(function (contexts) {
                contextsData = contexts;

                RestAPI.Loodle.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    getLoodleId(data.id, function (err, data) {
                        if (err) return callback(err);
                        loodleId = data;

                        return callback();
                    });
                });
            });

        });

        it('should add the schedule to the loodle', function (callback) {

            var schedule = {
                'begin_time': '03/17/2016 2:02 PM',
                'end_time': '03/17/2016 2:12 PM'
            };

            RestAPI.Loodle.addSchedule(contextsData['branden'].restContext, loodleId, schedule, function (err, data) {
                assert.equal(err, null);

                RestAPI.Loodle.getLoodle(contextsData['branden'].restContext, loodleId, function (err, data) {
                    assert.equal(err, null);
                    assert.equal(data.schedules[0].begin_time, '2016-03-17T13:02:00.000Z');
                    assert.equal(data.schedules[0].end_time, '2016-03-17T13:12:00.000Z');

                    return callback();
                });
            });

        });

        it('should create default votes for the users of the loodle in the added schedule', function (callback) {

            RestAPI.Loodle.getLoodle(contextsData['branden'].restContext, loodleId, function (err, data) {
                assert.equal(err, null);
                assert.equal(data.votes[0].user_id, data.users[0].id);
                assert.equal(data.votes[0].schedule_id, data.schedules[0].id);
                assert.equal(data.votes[0].vote, 0);

                return callback();

            });

        });

    });

    describe('deleteSchedule', function () {

        var contextsData,
            loodleId,
            loodle;

        // Create a loodle to play with
        before(function (callback) {

            setUpUsers(function (contexts) {
                contextsData = contexts;

                RestAPI.Loodle.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    getLoodleId(data.id, function (err, data) {
                        if (err) return callback(err);
                        loodleId = data

                        var schedule = {
                            'begin_time': '03/17/2016 2:02 PM',
                            'end_time': '03/17/2016 2:12 PM'
                        };

                        RestAPI.Loodle.addSchedule(contexts['branden'].restContext, loodleId, schedule, function (err, data) {
                            if (err) return callback(err);

                            RestAPI.Loodle.getLoodle(contexts['branden'].restContext, loodleId, function (err, data) {
                                if (err) return callback(err);
                                loodle = data;

                                return callback();
                            });
                        });
                    });
                });
            });

        });

        it('should delete the schedule from the loodle', function (callback) {

            RestAPI.Loodle.deleteSchedule(contextsData['branden'].restContext, loodleId, loodle.schedules[0].id, function (err, data) {
                assert.equal(err, null);

                RestAPI.Loodle.getLoodle(contextsData['branden'].restContext, loodleId, function (err, data) {
                    assert.equal(err, null);
                    assert.equal(data.schedules.length, 0);

                    return callback();
                });
            });
        });

        it('should delete the votes about the deleted schedule', function (callback) {

            RestAPI.Loodle.getLoodle(contextsData['branden'].restContext, loodleId, function (err, data) {
                assert.equal(err, null);
                assert.equal(data.votes.length, 0);

                return callback();
            });

        });
    });

    describe('updateVotes', function () {

        var contextsData,
            loodleId,
            loodle;

        // Create a loodle to play with
        before(function (callback) {

            setUpUsers(function (contexts) {
                contextsData = contexts;

                RestAPI.Loodle.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    getLoodleId(data.id, function (err, data) {
                        if (err) return callback(err);
                        loodleId = data

                        var schedule = {
                            'begin_time': '03/17/2016 2:02 PM',
                            'end_time': '03/17/2016 2:12 PM'
                        };

                        RestAPI.Loodle.addSchedule(contexts['branden'].restContext, loodleId, schedule, function (err, data) {
                            if (err) return callback(err);

                            RestAPI.Loodle.getLoodle(contexts['branden'].restContext, loodleId, function (err, data) {
                                if (err) return callback(err);
                                loodle = data;

                                return callback();
                            });
                        });
                    });
                });
            });

        });

        it('should update the specified votes', function (callback) {

            var votes = {};
            votes[loodle.votes[0].vote_id] = 1;

            RestAPI.Loodle.updateVotes(contextsData['branden'].restContext, loodleId, votes, function (err, data) {
                assert.equal(err, null);

                RestAPI.Loodle.getLoodle(contextsData['branden'].restContext, loodleId, function (err, data) {
                    assert.equal(err, null);
                    assert.equal(data.votes[0].vote_id, loodle.votes[0].vote_id);
                    assert.equal(data.votes[0].vote, 1);

                    return callback();
                });
            });

        });
    });

});
