// Module dependencies
var http = require('http');
var querystring = require('querystring');
var log = require('oae-logger').logger('oae-loodle-rest');
var async = require('async');

var ContentDAO = require('../../oae-content/lib/internal/dao');
var ContentConstants = require('../../oae-content/lib/constants').ContentConstants;

var EmitterAPI = require('oae-emitter');

var userAPI = require('../../oae-principals/lib/api.user');

var LoodleDAO = require('./internal/dao').loodles;
var UserDAO = require('./internal/dao').users;

var LoodleAPI = new EmitterAPI.EventEmitter();

/**
 * Update the loodle category
 *
 * @param ctx
 * @param contentId
 * @param callback
 */
var updateVisibility = exports.updateVisibility = function (ctx, contentId, visibility, callback) {

    var currentUserToken,
        loodleId;

    async.series({
        getToken: function (done) {
            UserDAO.getToken(ctx.user().id, function (err, token) {
                if (err) return done(err);

                currentUserToken = token;
                return done();
            })
        },
        getLoodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, function (err, data) {
                if (err) return done(err);

                loodleId = data;
                return done();
            });
        },
        update: function (done) {
            LoodleDAO.updateVisibility(ctx, currentUserToken, loodleId, visibility.visibility, done);
        }
    }, callback);

}

/**
 * Check if a user participate to a specified loodle
 *
 * @param userId
 * @param loodleId
 * @param callback
 */
var userIsInLoodle = exports.userIsInLoodle = function (ctx, userId, loodleId, callback) {

    UserDAO.hasLoodleAccount(userId, function (err, hasLoodleAccount) {
        if (err) return callback(err);

        // The user does not have a mirror acount in the loodle application
        if (!hasLoodleAccount) return callback(null, false);

        async.waterfall([
            // Get user token
            function getUserToken (done) {
                UserDAO.getToken(userId, done);
            },

            // Check if the user is already in the loodle
            function checkIfInLoodle (token, done) {
                UserDAO.isInLoodle(ctx, userId, loodleId, token, done);
            }
        ], callback);
    });

};

var getUser = exports.getUser = function (ctx, userId, callback) {

    async.waterfall([
        // Get user token
        function getUserToken (done) {
            UserDAO.getToken(userId, done);
        },
        // Get user informations from its mirror account in the loodle application
        function getUserInfo (token, done) {
            UserDAO.get(ctx, token, done);
        }
    ], callback);

};

/**
 * Add an user to a loodle
 *
 * @param ctx
 * @param userId
 * @param callback
 */
var addUserIfNeeded = exports.addUserIfNeeded = function (ctx, contentId, userId, callback) {

    async.parallel({
        loodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, done);
        },
        token: function (done) {
            UserDAO.getToken(userId, done);
        }
    }, function (err, data) {
        if (err) return callback(err);

        LoodleDAO.addUserIfNeeded(ctx, data.loodleId, userId, data.token, callback);
    });

};

/**
 * Get or create a mirror account for an user
 *
 * @param ctx
 * @param userId
 * @param callback
 */
var getOrCreateUser = exports.getOrCreateUser = function (ctx, userId, callback) {

    UserDAO.hasLoodleAccount(userId, function (err, hasLoodleAccount) {
        if (err) return callback(err);

        if (hasLoodleAccount) {
            getUser(ctx, userId, callback);
        }
        else {
            UserDAO.createLoodleAccount(ctx, ctx.user(), function (err) {
                if (err) return callback(err);
                getUser(ctx, userId, callback);
            });
        }
    });

};

/**
 *
 * Create a loodle in the loodle application
 *
 * @param  {Context}  ctx       		 Standard context object containing the current user and the current tenant
 * @param  {String}   contentId          Id matching the loodle id which will be created
 * @param  {String}   name               Name of the loodle
 * @param  {String}   description        Description of the loodle
 * @param  {Object}   additionalMembers  Members to add to the loodle additionnaly to the current user
 * @param  {Function} callback           Standard callback function
 */
exports.create = function (ctx, currentUser, contentId, name, description, visibility, additionalMembers, folders, callback) {

    var loodleId,
        token;

    async.series([
        // Create the current user mirror account in the loodle application if needed
        function createCurrentUserMirrorAccountIfNeeded (end) {
            UserDAO.createUserIfNeeded(ctx, currentUser.id, end);
        },
        // Get the current user token to communicate with the loodle application
        function getCurrentUserToken (end) {
            UserDAO.getToken(currentUser.id, function (err, data) {
                token = data;
                return end(err, data);
            });
        },
        // Call to the loodle api to create the loodle
        function createLoodle (end) {
            LoodleDAO.createLoodle(ctx, token, name, description, visibility, function (err, data) {
                if (err) return end(err);

                loodleId = data;
                return end();
            });
        },
        // Save in db the matching contentId - loodleId
        function saveMatch (end) {
            LoodleDAO.saveMatch(contentId, loodleId, end);
        },
        // Add the additional members to the loodle
        function addMembers (end) {
            // For all additionnal members
            // Creation of the mirror account in the loodle application if not known
            // Add the user to the loodle
            async.forEachOf(additionalMembers, function (value, userId, done) {

                // The current user already have a mirror account because we communicate with
                // the loodle application with its token
                if (userId === currentUser.id)
                    return done();

                async.series({
                    createUser: function (finish) {
                        UserDAO.createUserIfNeeded(ctx, userId, finish);
                    },
                    addUserToLoodle: function (finish) {
                        LoodleDAO.addUserToLoodle(ctx, token, loodleId, userId, finish);
                    }
                }, done);

            }, end);

        }
    ], callback);

};

exports.getFromContentId = function (ctx, currentUser, contentId, callback) {

    UserDAO.getToken(currentUser.id, function (err, token) {
        if (err) return callback(err);

        async.waterfall([
            // Get loodleId from ContentId
            function (end) {
                LoodleDAO.getLoodleId(contentId, end);
            },
            // Get loodle data using the loodleId
            function (loodleId, end) {
                LoodleDAO.getLoodleData(ctx, token, loodleId, end);
            }
        ], callback);

    });

};

exports.getPublicLoodleFromContentId = function (ctx, contentId, callback) {

    async.waterfall([
        // Get loodleId from ContentId
        function (end) {
            LoodleDAO.getLoodleId(contentId, end);
        },
        // Get loodle data using the loodleId
        function (loodleId, end) {
            LoodleDAO.getPublicLoodleData(ctx, loodleId, end);
        }
    ], callback);

};

/**
 * Delete the loodle in the loodle application
 *
 * @param  {Object}   currentUser 	Object representing the current user
 * @param  {String}   contentId   	Content identifier
 * @param  {Function} callback    	Standard callback function
 */
exports.delete = function (ctx, currentUser, contentId, callback) {

    async.parallel({
        token: 		async.apply(UserDAO.getToken, currentUser.id),
        loodleId: 	async.apply(LoodleDAO.getLoodleId, contentId),
    }, function (err, results) {
        if (err) { return callback(err); }
        LoodleDAO.deleteLoodle(ctx, results.token, results.loodleId, callback);
    });
};

/**
 * Update the members in the loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Object}   	changes   		Object with the user id as key and the role as value
 * @param  {Function} 	callback  		Standard callback function
 */
exports.updateMembers = function (ctx, loodleId, changes, callback) {

    // No changes
    if (Object.keys(changes).length === 0)
        return callback();

    async.waterfall([
        // Get the current user token
        async.apply(UserDAO.getToken, ctx.user().id),
        function (currentUserToken, done) {

            async.forEachOf(changes, function (role, userId, end) {
                updateMember(ctx, loodleId, userId, role, currentUserToken, end);
            }, done);

        }
    ], callback);

};

/**
 * Update the member of the loodle
 *
 * @param ctx
 * @param contentId
 * @param userId
 * @param currentUserToken
 * @param callback
 */
var updateMember = function (ctx, contentId, userId, role, currentUserToken, callback) {

    var loodleId;

    async.series({
        // Get loodle id from the content id
        getLoodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, function (err, data) {
                loodleId = data;
                return done(err, data);
            });
        },
        updateMember: function (done) {
            _updateMember(ctx, loodleId, userId, role, currentUserToken, done);
        }
        // OAE handles the rest of the update
    }, callback);

};

var _updateMember = function (ctx, loodleId, userId, role, currentUserToken, callback) {

    // The user was removed from the loodle
    if (!role) {
        LoodleDAO.removeUser(ctx, loodleId, userId, currentUserToken, callback);
    }
    // The user was either added to the loodle or its status has been updated
    else {
        async.series({
            // Create the user mirror account in the loodle application if needed
            createMirrorAccountIfNeeded: async.apply(UserDAO.createUserIfNeeded, ctx, userId),
            // If the user is not already in the loodle, associate him
            associateUserToLoodleIfNeeded: function (done) {
                LoodleDAO.addUserIfNeeded(ctx, loodleId, userId, currentUserToken, done);
            }
        }, callback)
    }

}

/**
 * Add a schedule to the specified loodle
 *
 * @param 	{Context}   ctx       		Standard context object containing the current user and the current tenant
 * @param 	{String}   	contentId 		Content identifier
 * @param 	{Object}   	schedule  		Schedule object
 * @param 	{Function} 	callback  		Standard callback function
 */
exports.addSchedule = function (ctx, loodleId, schedule, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.addSchedule, ctx, loodleId, schedule, currentUser.locale)
    ], callback);

};

/**
 * Delete a schedule to the specified loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	loodleId   		Loodle identifier
 * @param  {String}   	scheduleId 		Schedule identifier
 * @param  {Function} 	callback   		Standard callback function
 */
exports.deleteSchedule = function (ctx, loodleId, scheduleId, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.deleteSchedule, ctx, loodleId, scheduleId)
    ], callback);

};

/**
 * Update the votes of a user in a loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {Object}   	votes    		Vote object : vote id as key, vote as value
 * @param  {Function} callback 			Standard callback function
 */
exports.updateVotes = function (ctx, votes, loodleId, callback) {

    var currentUser = ctx.user();

    // Public user updating his/her votes
    if (!currentUser) {
        LoodleDAO.updatePublicVotes(ctx, loodleId, votes, callback);
    }
    else {
        UserDAO.getToken(currentUser.id, function (err, token) {
            LoodleDAO.updateVotes(ctx, token, loodleId, votes, callback);
        });
    }

};

/**
 * Emit a notification saying that the loodle's schedules has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateScheduleNotification = function (ctx, contentId, callback) {

    var ContentAPI = require('oae-content');
    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err)
            return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_LOODLE_SCHEDULES, ctx, contentObj);
        return callback();
    });

};

/**
 * Emit a notification saying that the loodle's votes has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateVoteNotification = function (ctx, contentId, callback) {

    var ContentAPI = require('oae-content');
    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err)
            return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_LOODLE_VOTES, ctx, contentObj);
        return callback();
    });

};

exports.getData = function (ctx, loodleId, callback) {

    var currentUser = ctx.user()

    if (currentUser) {
        async.waterfall([
            async.apply(UserDAO.getToken, currentUser.id),
            async.apply(LoodleDAO.get, ctx, loodleId)
        ], callback);
    }
    else {
        LoodleDAO.getPublicLoodleData(ctx, loodleId, callback);
    }

};

exports.addMemberWithVotes = function (ctx, loodleId, firstName, lastName, votes, callback) {
    votes = JSON.parse(votes);
    LoodleDAO.addMemberWithVotes(ctx, loodleId, firstName, lastName, votes, callback);
};

// Private functions ============================================

