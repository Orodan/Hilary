// Module dependencies
var _ = require('underscore');
var http = require('http');
var querystring = require('querystring');
var log = require('oae-logger').logger('oae-loodle-api');
var async = require('async');

var FoldersDAO = require('../../oae-folders/lib/internal/dao');
var LoodleDAO = require('./internal/dao').loodles;
var UserDAO = require('./internal/dao').users;
var ContentDAO = require('../../oae-content/lib/internal/dao');

var ContentConstants = require('../../oae-content/lib/constants').ContentConstants;
var PrincipalsConstants = require('../../oae-principals/lib/constants').PrincipalsConstants;
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;
var FoldersConstants = require('oae-folders/lib/constants').FoldersConstants;

var FoldersAPI = require('oae-folders');
var ContentAPI = require('oae-content');
var userAPI = require('../../oae-principals/lib/api.user');
var groupAPI = require('../../oae-principals/lib/api.group');
var EmitterAPI = require('oae-emitter');
var GroupAPI = require('../../oae-principals/lib/api.group');
var PrincipalsUtil = require('../../oae-principals/lib/util');
var LibraryAPI = require('oae-library');
var AuthzAPI = require('oae-authz');
var ContentMembersLibrary = require('../../oae-content/lib/internal/membersLibrary');
var PrincipalsMembersLibrary = require('../../oae-principals/lib/libraries/members');
var LoodleAPI = new EmitterAPI.EventEmitter();

var PrincipalsEmitter = require('../../oae-principals/lib/internal/emitter');

var util = require('../../oae-authz/lib/util');
var ContentUtil = require('../../oae-content/lib/internal/util');

FoldersAPI.when(FoldersConstants.events.UPDATED_FOLDER_MEMBERS, function (ctx, folder, memberChangeInfo, something, callback) {

    // Check if the folder library has some loodles, otherwise we have nothing to do
    getFolderLoodles(ctx, folder, function (err, contents) {
        if (err) return callback(err);
        if (!contents.length) return callback();

        createAccountForFolderMembers(ctx, folder.id, callback);
    });

});

var getFolderLoodles = function (ctx, folder, callback) {

    FoldersAPI.getFolderContentLibrary(ctx, folder.id, 0, 1000, function (err, contentObjects) {
        if (err) return callback(err);

        // Filter only the loodle contents
        contentObjects = _.filter(contentObjects, function (content) {
            return content.resourceSubType === 'loodle';
        });

        return callback(null, contentObjects);
    });

};

FoldersAPI.when(FoldersConstants.events.ADDED_CONTENT_ITEMS, function (ctx, actionContext, folder, contentItems, callback) {

    var loodleItems = _.find(contentItems, function (item) {
        return item.resourceSubType === 'loodle';
    });

    if (!hasLoodleItems(contentItems)) {
        return callback();
    }

    createAccountForFolderMembers(ctx, folder.id, function (err) {
        return callback(err);
    });

});

var hasLoodleItems = function (contentItems) {

    var loodleItems = _.find(contentItems, function (item) {
        return item.resourceSubType === 'loodle';
    });

    if (loodleItems === undefined)
        return false;
    else
        return true;

};

var getLoodle = function (ctx, content, callback) {

    var currentUser = ctx.user();

    if (content.visibility === 'private') {
        getPrivateLoodle(ctx, currentUser, content, callback);
    }
    else if (content.visibility === 'loggedin' || content.visibility === 'public') {
        getPublicLoodle(ctx, currentUser, content, callback);
    }
    else {
        return callback({ code: '500', msg: 'invalid visibility '});
    }

};

var getPublicLoodle = function (ctx, currentUser, content, callback) {

    // An user is connected
    if (currentUser) {
        getPublicLoodleFromContentId(ctx, content.id, function (err, loodle) {
            if (err) return callback(err);

            content.loodleData = loodle;

            // Check if the user is a participant in the loodle or access it in read only mode
            userIsInLoodle(ctx, currentUser.id, loodle.id, function (err, isInLoodle) {
                if (err) return callback(err);
                if (!isInLoodle) return callback(null, content);

                getUser(ctx, currentUser.id, function (err, user) {
                    if (err) return callback(err);

                    content.loodleData.currentUser = user;
                    return callback(null, content);
                });
            });
        });
    }
    // An anonymous user is accessing the loodle, just send back the loodle data
    else {
        getPublicLoodleFromContentId(ctx, content.id, function (err, loodle) {
            if (err) return callback(err);

            content.loodleData = loodle;
            return callback(null, content);
        });
    }

};

var getPrivateLoodle = function (ctx, currentUser, content, callback) {

    getFromContentId(ctx, currentUser, content.id, function (err, loodle) {
        if (err) return callback(err);

        content.loodleData = loodle;

        // Check if the user is a participant in the loodle or access it in read only mode
        userIsInLoodle(ctx, currentUser.id, loodle.id, function (err, isInLoodle) {
            if (err) return callback(err);

            if (!isInLoodle) return callback(null, content);

            getUser(ctx, currentUser.id, function (err, user) {
                if (err) return callback(err);

                content.loodleData.currentUser = user;
                return callback(null, content);
            });
        });
    });

};


ContentAPI.when(ContentConstants.events.GET_CONTENT, function (ctx, contentObj, callback) {

    if (!(contentObj.resourceSubType === 'loodle'))
        return callback(null, contentObj);

    getLoodle(ctx, contentObj, function (err, contentObj) {
        if (err) return callback(err);

        return callback(null, contentObj);
    });

});

ContentAPI.when(ContentConstants.events.CREATED_CONTENT, function (ctx, content, revision, memberChangeInfo, folders, callback) {

    if (!(content.resourceSubType === 'loodle'))
        return callback(null, content);

    create(ctx, ctx.user(), content.id, content.displayName, content.description, content.visibility, memberChangeInfo.changes, folders, function (err) {
        if (err) return callback(err);

        return callback(null, content);
    });

});

ContentAPI.when(ContentConstants.events.DELETED_CONTENT, function (ctx, contentObj, members, callback) {

    if (!(contentObj.resourceSubType === 'loodle'))
        return callback(null, contentObj);

    deleteLoodle(ctx, ctx.user(), contentObj.id, callback);

});

ContentAPI.when(ContentConstants.events.UPDATED_CONTENT_MEMBERS, function (ctx, content, memberChangeInfo, something, callback) {

    if (!(content.resourceSubType === 'loodle'))
        return callback(null, content);

    updateMembers(ctx, content.id, memberChangeInfo.changes, callback);

});

ContentAPI.when(ContentConstants.events.UPDATED_CONTENT, function (ctx, newContentObj, oldContentObj, callback) {

    if (!(content.resourceSubType === 'loodle'))
        return callback(null, content);

    updateVisibility(ctx, contentId, newContentObj.visibility, callback);

});

/**
PrincipalsEmitter.when(PrincipalsConstants.events.DELETED_GROUP, function (ctx, group, callback) {

    // Check if the group library has somme loodles, otherwise we have nothing to do
    getGroupLoodles(ctx, group, function (err, contents) {
        if (err) return callback(err);
        if (!contents.length) return callback();


        removeGroupMembersFromLoodles(ctx, group, contents, function (err) {
            return callback(err);
        });

    });

});
 **/

// Update has been made on group members
PrincipalsEmitter.when(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, function (ctx, group, oldGroup, memberChangeInfo, opts, callback) {

    // Check if the group library has some loodles, otherwise we have nothing to do
    getGroupLoodles(ctx, group, function (err, contents) {
        if (err) return callback(err);
        if (!contents.length) return callback();

        setGroupMembers(ctx, contents, memberChangeInfo, callback);
    });

});

/**
 * Remove group members from a loodle
 * @param ctx
 * @param group
 * @param content
 * @param token
 * @param callback
 */
var removeGroupMembersFromLoodle = function (ctx, group, content, token, callback) {

    // Get member ids that need to be deleted from the loodle
    async.parallel({
        mappedUserIds: function (done) {

            async.waterfall([
                async.apply(getUserIdsFromContentId, ctx, content.id),
                async.apply(mapOAEUserIdsWithLoodleUserIds, ctx)
            ], function (err, data) {
                return done(err, data);
            });

        },
        loodleUserIds: function (done) {

            async.waterfall([
                async.apply(LoodleDAO.getLoodleId, content.id),
                async.apply(getUserIdsFromLoodle, ctx, token)
            ], function (err, data) {
                return done(err, data);
            });

        }
    }, function (err, data) {
        if (err) return callback(err);

        var userIdsLoodleFormat = _.map(data['mappedUserIds'], function (value, key) {
            return key;
        });

        var userIdsToRemove = _.difference(data['loodleUserIds'], userIdsLoodleFormat);

        var OAEuserIdsToRemove = _.map(userIdsToRemove, function (userId) {
            return data['mappedUserIds'][userId];
        });

        // Remove the users from the loodle
        async.each(OAEuserIdsToRemove, function (userId, done) {
            removeUserFromLoodle(ctx, content, userId, token, done);
        }, callback);
    });
};

/**
 * Remove group members from loodles
 * @param ctx
 * @param group
 * @param contents
 * @param callback
 */
var removeGroupMembersFromLoodles = function (ctx, group, contents, callback) {

    UserDAO.getToken(ctx.user().id, function (err, token) {
        if (err) return callback(err);

        async.each(contents, function (content, done) {
            removeGroupMembersFromLoodle(ctx, group, content, token, done);
        }, callback);
    });

};

var getLoodleMembers = function (ctx, content, groupId, callback) {

    // Determine if and how the current user should access the content members library
    LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, content.id, content, function(err, hasAccess, visibility) {
        if (err) return callback(err);
        if (!hasAccess) return callback({'code': 401, 'msg': 'You are not authorized to access the members of this content item'});

        // Get the members of the content item from the members library
        ContentMembersLibrary.list(content, visibility, {'start': 0, 'limit': null}, function(err, memberIds, nextToken) {
            if (err) return callback(err);
            if (_.isEmpty(memberIds)) return callback(null, [], nextToken);

            async.each(memberIds, function (memberId, done) {
                if (!(util.isGroupId(memberId))) return done();
                if (memberId === groupId) {
                    memberIds = _.without(memberIds, memberId);
                    return done();
                }

                // Check if the group has not been deleted (OAE does not remove the content access of deleted group)
                GroupAPI.getGroup(ctx, memberId, function (err, group) {
                    if (err) return done(err);
                    if (group.deleted) return done();

                    // We get all of its members
                    getGroupMembers(ctx, memberId, function (err, groupMembers) {

                        // Delete the group id from the member ids
                        memberIds = _.without(memberIds, memberId);

                        // Add the members of the group to the member ids (if they are not already in)
                        groupMembers.forEach(function (userId) {
                            if (!(_.contains(memberIds, userId))) {
                                memberIds.push(userId);
                            }
                        });

                        return done();
                    });
                });
            }, function (err) {
                if (err) return callback(err);
                return callback(null, memberIds);
            });
        });
    });

};

/**
 * Get all the loodle type contents inside of the group library
 *
 * @param ctx
 * @param group
 * @param callback
 */
var getGroupLoodles = function (ctx, group, callback) {

    // Determine which library visibility we need to fetch
    LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, group.id, group, function(err, hasAccess, visibility) {
        if (err) return callback(err);
        if (!hasAccess) return callback({'code': 401, 'msg': 'You do not have access to this library'});

        ContentDAO.Content.getContentLibraryItems(group.id, visibility, 0, null, function(err, contentObjects) {
            if (err) return callback(err);

            // Filter only the loodle contents
            contentObjects = _.filter(contentObjects, function (content) {
                return content.resourceSubType === 'loodle';
            });

            return callback(null, contentObjects);
        });
    });

};

/**
 * Apply the updates about the group members to the loodles
 *
 * @param contents
 * @param memberChangeInfo
 * @param callback
 */
var setGroupMembers = function (ctx, contents, memberChangeInfo, callback) {

    // Get the token of the current user
    UserDAO.getToken(ctx.user().id, function (err, token) {
        if (err) return callback(err);

        async.parallel({
            added: function (done) {
                if (memberChangeInfo.members.added.length === 0) return done();

                addUsersToLoodles(ctx, contents, memberChangeInfo, token, done);
            },
            removed: function (done) {
                if (memberChangeInfo.members.removed.length === 0) return done();

                removeMembersFromLoodles(ctx, contents, memberChangeInfo, token, done);
            }
        }, callback);
    });

};

/**
 * Add the users to the loodles
 *
 * @param contents
 * @param memberChangeInfo
 * @param token
 * @param callback
 */
var addUsersToLoodles = function (ctx, contents, memberChangeInfo, token, callback) {

    // For each user added
    async.each(memberChangeInfo.members.added, function (addedMember, done) {

        if (util.isUserId(addedMember.id)) {
            addUserToLoodles(ctx, contents, addedMember.id, token, done);
        }
        else if (util.isGroupId(addedMember.id)) {
            addGroupToLoodles(ctx, contents, addedMember.id, token, done);
        }
        else {
            return done({code: 500, msg: 'Invalid member id'});
        }

    }, callback);

};

var addUserToLoodles = function (ctx, contents, userId, token, callback) {

    // For each loodle content
    async.eachSeries(contents, function (content, done) {

        async.series({
            loodleOAEUsers: function (finish) {
                ContentAPI.getContentMembersLibrary(ctx, content.id, 0, 1000, function (err, members) {
                    if (err) return finish(err);

                    var memberIds = _.pluck(_.pluck(members, 'profile'), 'id');

                    async.forEachOf(memberIds, function (memberId, index, over) {
                        if (!util.isGroupId(memberId)) return over();

                        getGroupMemberIds(ctx, memberId, function (err, groupUserIds) {
                            if (err) return over(err);

                            // Delete the group id
                            memberIds.splice(index, 1);
                            // Add the group user ids
                            memberIds = _.union(memberIds, groupUserIds);
                            return over();
                        });
                    }, function (err) {
                        if (err) return finish(err);

                        var loodleOAEUserIds = {};
                        async.eachSeries(memberIds, function (userId, over) {
                            getOrCreateUser(ctx, userId, function (err, userData) {
                                if (err) return over(err);

                                loodleOAEUserIds[userData.id] = userId;
                                return over();
                            });
                        }, function (err) {
                            if (err) return finish(err);
                            return finish(null, loodleOAEUserIds);
                        });
                    });
                });
            },
            loodleUsers: function (finish) {
                LoodleDAO.getLoodleId(content.id, function (err, loodleId) {
                    if (err) return finish(err);

                    // Get the loodle users from the Loodle application
                    LoodleDAO.getLoodleData(ctx, token, loodleId, function (err, loodle) {
                        if (err) return finish(err);

                        var userIds = _.pluck(loodle.users, 'id');
                        return finish(null, userIds);
                    });
                });
            }
        }, function (err, results) {
            if (err) return done(err);

            var OAEUserIds = _.map(results['loodleOAEUsers'], function (value, key) {
                return key;
            });

            // Check the difference between the users registred in OAE and the users registred
            // in the Loodle application --> the users to add
            var userIdsToAdd = _.difference(OAEUserIds, results['loodleUsers']);

            LoodleDAO.getLoodleId(content.id, function (err, loodleId) {
                if (err) return done(err);

                async.eachSeries(userIdsToAdd, function (userId, finish) {
                    LoodleDAO.addUserToLoodle(ctx, token, loodleId, results['loodleOAEUsers'][userId], finish);
                }, done);
            });
        });

    }, callback);

};

/**
 * Add the groups users to the loodle
 * @param ctx
 * @param contents
 * @param groupId
 * @param token
 * @param callback
 */
var addGroupToLoodles = function (ctx, contents, groupId, token, callback) {

    // When this function is called, the group has already been added to the content members in OAE
    // Therefore, we need to get all the users registred in the content in OAE, all the
    // users registred in the loodle in the Loodle application, and make the difference to
    // get all the users who need to be added as participants

    async.each(contents, function (content, done) {
        addGroupToLoodle(ctx, content, groupId, token, done);
    }, callback);

};

/**
 * Add the group users to the loodle
 * @param ctx
 * @param content
 * @param groupId
 * @param token
 * @param callback
 */
var addGroupToLoodle = function (ctx, content, groupId, token, callback) {

    async.parallel({
        mappedUserIds: function (done) {

            async.waterfall([
                async.apply(getUserIdsFromContentId, ctx, content.id),
                function (userIds, finish) {
                    createLoodleAccountsIfNeeded(ctx, userIds, function (err) {
                        if (err) return finish(err);
                        return finish(null, userIds);
                    });
                },
                async.apply(mapOAEUserIdsWithLoodleUserIds, ctx)
            ], function (err, data) {
                return done(err, data);
            });

        },
        loodleUserIds: function (done) {

            async.waterfall([
                async.apply(LoodleDAO.getLoodleId, content.id),
                async.apply(getUserIdsFromLoodle, ctx, token)
            ], function (err, data) {
                return done(err, data);
            });

        }
    }, function (err, data) {
        if (err) return callback(err);

        var userIdsLoodleFormat = _.map(data['mappedUserIds'], function (value, key) {
            return key;
        });

        var userIdsToAdd = _.difference(userIdsLoodleFormat, data['loodleUserIds']);

        async.waterfall([
            async.apply(LoodleDAO.getLoodleId, content.id),
            function (loodleId, done) {
                async.each(userIdsToAdd, function (userId, finish) {
                    LoodleDAO.addUserToLoodle(ctx, token, loodleId, data['mappedUserIds'][userId], finish);
                }, done);
            }
        ], callback);
    });

};

/**
 * Get all the ids of all the users who have access to the content
 * @param ctx
 * @param contentId
 * @param callback
 */
var getUserIdsFromContentId = function (ctx, contentId, callback) {

    var userIds = [];

    // Get all members
    ContentAPI.getContentMembersLibrary(ctx, contentId, 0, 1000, function (err, members) {
        if (err) return callback(err);

        // For each members
        async.each(members, function (member, done) {

            if (util.isUserId(member.profile.id)) {
                userIds.push(member.profile.id);
                return done();
            }
            // If group id --> get all users and add them to the list of users
            else if (util.isGroupId(member.profile.id)) {
                // OAE keeps as members deleted group, so we should check
                // if (!(member.profile.deleted === undefined)) return done();
                getGroupUserIds(ctx, member.profile.id, function (err, groupUserIds) {
                    if (err) return done(err);

                    userIds = _.union(userIds, groupUserIds);
                    return done();
                });
            }
            else {
                return done({code: 500, msg: 'Invalid member id'});
            }

        }, function (err) {
            if (err) return callback(err);
            return callback(null, userIds);
        });

    });

};

/**
 * Get the ids of all the users of the group (including sub groups)
 * @param ctx
 * @param groupId
 * @param callback
 */
var getGroupUserIds = function (ctx, groupId, callback) {

    _getGroupUserIds(ctx, groupId, [], callback);

};

/**
 * Recursive function that get the ids of all the group users (including sub groups)
 * @param ctx
 * @param groupId
 * @param processedGroupIds
 * @param callback
 * @private
 */
var _getGroupUserIds = function (ctx, groupId, processedGroupIds, callback) {

    var userIds = [];

    if (_.contains(processedGroupIds, groupId)) return callback(null, userIds);

    // Add the current group id to the processed group so that we don't process it again
    // in a case like the following one :
    // Group A ; members : Branden, Group B
    // Group B ; members : Ian, Group A
    processedGroupIds.push(groupId);

    // Get the members of the group
    PrincipalsMembersLibrary.list({id: groupId}, AuthzConstants.visibility.PRIVATE, {'start': 0, 'limit': 1000}, function(err, groupMembers) {
    // groupAPI.getMembersLibrary(ctx, groupId, 0, 1000, function (err, groupMembers) {
        if (err) return callback(err);

        async.each(groupMembers, function (member, done) {
            // If user id, add to the list of the users
            if  (util.isUserId(member.id)) {
                userIds.push(member.id);
                return done();
            }
            // If group id, call the same function with the group id compute the union of the result with the actul list of users
            else if (util.isGroupId(member.id)) {
                _getGroupUserIds(ctx, member.id, processedGroupIds, function (err, subGroupUserIds) {
                    if (err) return done(err);

                    userIds = _.union(userIds, subGroupUserIds);
                    return done();
                });
            }
            else {
                return done({code: 500, msg: 'Invalid member id'});
            }
        }, function (err) {
            if (err) return callback(err);
            return callback(null, userIds);
        });
    });

};

/**
 * Create a loodle account for every user in the userIds array if they need to
 * @param ctx
 * @param userIds
 * @param callback
 */
var createLoodleAccountsIfNeeded = function (ctx, userIds, callback) {

    async.each(userIds, function (userId, done) {
        UserDAO.createUserIfNeeded(ctx, userId, done);
    }, callback);

};

/**
 * Create a mapped object with the user ids
 * Return a object with the loodle user ids as key and the OAE user ids as value
 * @param ctx
 * @param userIds
 * @param callback
 */
var mapOAEUserIdsWithLoodleUserIds = function (ctx, userIds, callback) {

    var mappedUserIds = {};

    async.each(userIds, function (userId, done) {
        async.waterfall([
            async.apply(UserDAO.getToken, userId),
            async.apply(UserDAO.get, ctx)
        ], function (err, user) {
            if (err) done(err);

            mappedUserIds[user.id] = userId;
            return done();
        });
    }, function (err) {
        if (err) return callback(err);
        return callback(null, mappedUserIds);
    });

};

/**
 * Get the ids of the loodle users (registred in the Loodle application)
 * @param ctx
 * @param loodleId
 * @param callback
 */
var getUserIdsFromLoodle = function (ctx, token, loodleId, callback) {

    async.waterfall([
        async.apply(LoodleDAO.get, ctx, loodleId, token),
        function (loodle, done) { return done(null, _.pluck(loodle.users, 'id')); }
    ], callback);

};

/**
 * Remove users from loodles
 *
 * @param loodles
 * @param users
 * @param callback
 */
var removeMembersFromLoodles = function (ctx, contents, memberChangeInfo, token, callback) {

    // For each member removed
    async.each(memberChangeInfo.members.removed, function (removedMember, done) {

        if (util.isUserId(removedMember.id)) {
            removeUserFromLoodles(ctx, contents, removedMember.id, token, callback);
        }
        else if (util.isGroupId(removedMember.id)) {
            removeGroupFromLoodles(ctx, contents, removedMember.id, token, callback);
        }
        else {
            return callback({code: 500, msg: 'Invalid member id'});
        }

    }, callback);

};

/**
 * Remove an user from loodles
 * @param ctx
 * @param contents
 * @param userId
 * @param token
 * @param callback
 */
var removeUserFromLoodles = function (ctx, contents, userId, token, callback) {

    async.each(contents, function (content, done) {
        removeUserFromLoodle(ctx, content, userId, token, done);
    }, callback);

};

/**
 * Remove an user from a loodle
 * @param ctx
 * @param content
 * @param userId
 * @param token
 * @param callback
 */
var removeUserFromLoodle = function (ctx, content, userId, token, callback) {

    ContentAPI.getContentMembersLibrary(ctx, content.id, 0, 1000, function (err, members) {
        if (err) return callback(err);

        var memberIds = _.pluck(_.pluck(members, 'profile'), 'id');

        // Get user ids of the group members of the loodle
        async.each(memberIds, function (memberId, done) {
            if (!util.isGroupId(memberId)) {
                return done();
            }

            getGroupMemberIds(ctx, memberId, function (err, groupMemberIds) {
                if (err) return done(err);

                memberIds = _.union(memberIds, groupMemberIds);
                return done();
            });
        }, function (err) {
            if (err) return callback(err);

            // We don't suppress as participant someone who has another access to the loodle
            if (_.contains(memberIds, userId)) return callback();

            LoodleDAO.getLoodleId(content.id, function (err, loodleId) {
                if (err) return callback(err);

                // The user does not have any access to the loodle anymore, we remove him/her as participant
                LoodleDAO.removeUser(ctx, loodleId, userId, token, callback);
            });
        });

    });

};

var removeGroupFromLoodles = function (ctx, contents, groupId, token, callback) {

    async.each(contents, function (content, done) {

        ContentAPI.getContentMembersLibrary(ctx, content.id, 0, 1000, function (err, members) {
            if (err) return done(err);

            var memberIds = _.pluck(_.pluck(members, 'profile'), 'id');

            // If the entire group does have another access to the loodle, we don't suppress the group users as participants
            if (_.contains(memberIds, groupId)) return done();

            async.each(memberIds, function (memberId, finish) {
                if (!util.isGroupId(memberId)) {
                    return finish();
                }

                getGroupMemberIds(ctx, memberId, function (err, groupMemberIds) {
                    if (err) return finish(err);

                    memberIds = _.union(memberIds, groupMemberIds);
                    return finish();
                });
            }, function (err) {
                if (err) return done(err);

                // The entire group does not have another access, check now every group user
                getGroupMemberIds(ctx, groupId, function (err, groupUserIds) {
                    async.each(groupUserIds, function (userId, finish) {
                        if (_.contains(memberIds, userId)) return finish();

                        LoodleDAO.getLoodleId(content.id, function (err, loodleId) {
                            if (err) return finish(err);

                            // The user does not have any access to the loodle anymore, we remove him/her as participant
                            LoodleDAO.removeUser(ctx, loodleId, userId, token, finish);
                        });
                    }, done);
                });
            });
        });

    }, callback);

};

var getGroupMembers = function (ctx, groupId, callback) {

    var groupMembers = [];

    groupAPI.getMembersLibrary(ctx, groupId, 0, null, function (err, data) {
        if (err) return callback(err);

        data.forEach(function (member) {
            groupMembers.push(member.profile.id);
        });

        return callback(null, groupMembers);
    });

};

var getGroupsMembers = function (ctx, groups, callback) {

    // TODO : gérer le cas d'un groupe A membre d'un groupe B qui est lui même membre du groupe A

    var groupsMembers = {};

    async.forEachOf(groups, function (role, groupId, done) {
        getGroupMemberIds(ctx, groupId, function (err, groupMembers) {
            if (err) return done(err);

            groupMembers.forEach(function (id) {
                // If the user was already in another group
                if (id in groupsMembers) {
                    if (groupsMembers[id] === 'manager' || role === 'manager') {
                        groupsMembers[id] = 'manager';
                    }
                    else {
                        groupsMembers[id] = 'viewer';
                    }
                }
                else {
                    groupsMembers[id] = role;
                }
            });

            return done();
        });
    }, function (err) {
        if (err) return callback(err);

        return callback(null, groupsMembers);
    });

};

/**
 * Update the loodle category
 *
 * @param ctx
 * @param contentId
 * @param callback
 */
var updateVisibility = exports.updateVisibility = function (ctx, contentId, visibility, callback) {

    var currentUserToken,
        loodleId;

    async.series({
        getToken: function (done) {
            UserDAO.getToken(ctx.user().id, function (err, token) {
                if (err) return done(err);

                currentUserToken = token;
                return done();
            })
        },
        getLoodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, function (err, data) {
                if (err) return done(err);

                loodleId = data;
                return done();
            });
        },
        update: function (done) {
            LoodleDAO.updateVisibility(ctx, currentUserToken, loodleId, visibility.visibility, done);
        }
    }, callback);

}

/**
 * Check if a user participate to a specified loodle
 *
 * @param userId
 * @param loodleId
 * @param callback
 */
var userIsInLoodle = exports.userIsInLoodle = function (ctx, userId, loodleId, callback) {

    UserDAO.hasLoodleAccount(userId, function (err, hasLoodleAccount) {
        if (err) return callback(err);

        // The user does not have a mirror acount in the loodle application
        if (!hasLoodleAccount) return callback(null, false);

        async.waterfall([
            // Get user token
            function getUserToken (done) {
                UserDAO.getToken(userId, done);
            },

            // Check if the user is already in the loodle
            function checkIfInLoodle (token, done) {
                UserDAO.isInLoodle(ctx, userId, loodleId, token, done);
            }
        ], callback);
    });

};

var getUser = exports.getUser = function (ctx, userId, callback) {

    async.waterfall([
        // Get user token
        function getUserToken (done) {
            UserDAO.getToken(userId, done);
        },
        // Get user informations from its mirror account in the loodle application
        function getUserInfo (token, done) {
            UserDAO.get(ctx, token, done);
        }
    ], callback);

};

/**
 * Add an user to a loodle
 *
 * @param ctx
 * @param userId
 * @param callback
 */
var addUserIfNeeded = exports.addUserIfNeeded = function (ctx, contentId, userId, callback) {

    async.parallel({
        loodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, done);
        },
        token: function (done) {
            UserDAO.getToken(userId, done);
        }
    }, function (err, data) {
        if (err) return callback(err);

        LoodleDAO.addUserIfNeeded(ctx, data.loodleId, userId, data.token, callback);
    });

};

/**
 * Get or create a mirror account for an user
 *
 * @param ctx
 * @param userId
 * @param callback
 */
var getOrCreateUser = exports.getOrCreateUser = function (ctx, userId, callback) {

    UserDAO.hasLoodleAccount(userId, function (err, hasLoodleAccount) {
        if (err) return callback(err);

        if (hasLoodleAccount) {
            getUser(ctx, userId, callback);
        }
        else {
            userAPI.getUser(ctx, userId, function (err, user) {
                if (err) return callback(err);

                UserDAO.createLoodleAccount(ctx, user, function (err) {
                    if (err) return callback(err);

                    getUser(ctx, userId, function (err, data) {
                        if (err) return callback(err);
                        return callback(null, data);
                    });
                });
            });
        }
    });

};

/**
 * Create a loodle account for every member of the loodle (if they don't already have one)
 * @param folderId
 * @param callback
 */
var createAccountForFolderMembers = function (ctx, folderId, callback) {

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {
        if (err) return callback(err);

        AuthzAPI.getAuthzMembers(folder.groupId, null, 1000, function(err, members, nextToken) {
            if (err) return callback(err);

            async.each(members, function (member, done) {
                // The member is an user
                if (util.isUserId(member.id)) {
                    UserDAO.createUserIfNeeded(ctx, member.id, done);
                }
                // The member is a group
                else if (util.isGroupId(member.id)) {
                    getGroupUserIds(ctx, member.id, function (err, groupUserIds) {
                        if (err) return done(err);

                        async.each(groupUserIds, function (userId, finish) {
                            UserDAO.createUserIfNeeded(ctx, userId, finish);
                        }, done);
                    });
                }
                // Invalid member id
                else {
                    return done({code: 500, msg: 'Invalid member id'});
                }

            }, callback);
        });

    });

};

/**
 *
 * Create a loodle in the loodle application
 *
 * @param  {Context}  ctx       		 Standard context object containing the current user and the current tenant
 * @param  {String}   contentId          Id matching the loodle id which will be created
 * @param  {String}   name               Name of the loodle
 * @param  {String}   description        Description of the loodle
 * @param  {Object}   additionalMembers  Members to add to the loodle additionnaly to the current user
 * @param  {Function} callback           Standard callback function
 */
var create = exports.create = function (ctx, currentUser, contentId, name, description, visibility, additionalMembers, folders, callback) {

    var cloneAdditionalMembers = {};
    var loodleId,
        token;

    async.series([
        // Even if members of a folder only have a read only access if the loodle is created inside
        // a folder, we still neeed to create a mirror account for them (if they don't already have
        // one), otheriwe they will not be able to access the loodle data
        function createMirrorAccountForFoldersMembers (end) {
            async.each(folders, function (folderId, finish) {
                createAccountForFolderMembers(ctx, folderId, finish);
            }, end);
        },
        function cloningAdditionalMembers (end) {
            async.forEachOf(additionalMembers, function (value, key, finish) {
                cloneAdditionalMembers[key] = value;
                return finish();
            }, end);
        },
        // Create the current user mirror account in the loodle application if needed
        function createCurrentUserMirrorAccountIfNeeded (end) {
            UserDAO.createUserIfNeeded(ctx, currentUser.id, end);
        },
        // Get the current user token to communicate with the loodle application
        function getCurrentUserToken (end) {
            UserDAO.getToken(currentUser.id, function (err, data) {
                token = data;
                return end(err, data);
            });
        },
        // Call to the loodle api to create the loodle
        function createLoodle (end) {
            LoodleDAO.createLoodle(ctx, token, name, description, visibility, function (err, data) {
                if (err) return end(err);

                // Delete the current user from the additional members as he/she is already associated
                // with the new loodle created
                delete cloneAdditionalMembers[currentUser.id]

                loodleId = data;
                return end();
            });
        },
        // Save in db the matching contentId - loodleId
        function saveMatch (end) {
            LoodleDAO.saveMatch(contentId, loodleId, end);
        },
        function getGroupUsers (end) {
            async.forEachOf(cloneAdditionalMembers, function (role, id, finish) {
                if(!util.isGroupId(id)) {
                    return finish();
                }

                getGroupMemberIds(ctx, id, function (err, groupMemberIds) {
                    if (err) return finish(err)

                    groupMemberIds.forEach(function (groupMemberId) {
                        if (!(groupMemberId in cloneAdditionalMembers) && groupMemberId != currentUser.id) {
                            cloneAdditionalMembers[groupMemberId] = 'manager';
                        }
                    });

                    delete cloneAdditionalMembers[id];

                    return finish();
                });
            }, end);
        },
        function addMembers (end) {
            addUsers(ctx, cloneAdditionalMembers, token, loodleId, end);
        }
    ], callback);

};

/**
 * Recursive function that get all the group members. If a group is member of
 * another group, we get all its users.
 *
 * @param ctx
 * @param groupId
 * @param callback
 */
var getGroupMemberIds = function (ctx, groupId, callback) {

    var users = [];

    // Instead of using the GroupAPI.getMembersLibrary, we use the PrincipalsMembersLibrary to avoid having
    // insufficient privilege when getting the group member ids
    PrincipalsMembersLibrary.list({id: groupId}, AuthzConstants.visibility.PRIVATE, {'start': 0, 'limit': 1000}, function(err, memberEntries, nextToken) {
        if (err) return callback(err);

        var memberIds = _.pluck(memberEntries, 'id');
        async.each(memberIds, function (memberId, done) {
            if (!util.isGroupId(memberId)) {
                users.push(memberId);
                return done();
            }

            getGroupMemberIds(ctx, memberId, function (err, subgroupMembers) {
                if (err) return done(err);

                users = _.union(users, subgroupMembers);
                return done();
            });

        }, function (err) {
            if (err) return callback(err);

            return callback(null, users);
        });

    });

};



/**
 * Add users to a loodle
 *
 * @param ctx
 * @param additionalMembers
 * @param token
 * @param loodleId
 * @param callback
 */
var addUsers = function (ctx, additionalMembers, token, loodleId, callback) {

    async.forEachOf(additionalMembers, function (role, id, done) {
        addUser(ctx, id, token, loodleId, done);
    }, callback);

};

/**
 * Add a user to a loodle
 *
 * @param ctx
 * @param userId
 * @param token
 * @param loodleId
 * @param callback
 */
var addUser = function (ctx, userId, token, loodleId, callback) {

    async.series({
        createUser: function (done) {
            UserDAO.createUserIfNeeded(ctx, userId, done);
        },
        addUserToLoodle: function (done) {
            LoodleDAO.addUserToLoodle(ctx, token, loodleId, userId, done);
        }
    }, callback);

};

var getFromContentId = exports.getFromContentId = function (ctx, currentUser, contentId, callback) {

    UserDAO.getToken(currentUser.id, function (err, token) {
        if (err) return callback(err);

        async.waterfall([
            // Get loodleId from ContentId
            function (end) {
                LoodleDAO.getLoodleId(contentId, end);
            },
            // Get loodle data using the loodleId
            function (loodleId, end) {
                LoodleDAO.getLoodleData(ctx, token, loodleId, end);
            }
        ], callback);

    });

};

var getPublicLoodleFromContentId = exports.getPublicLoodleFromContentId = function (ctx, contentId, callback) {

    async.waterfall([
        // Get loodleId from ContentId
        function (end) {
            LoodleDAO.getLoodleId(contentId, end);
        },
        // Get loodle data using the loodleId
        function (loodleId, end) {
            LoodleDAO.getPublicLoodleData(ctx, loodleId, end);
        }
    ], callback);

};

/**
 * Delete the loodle in the loodle application
 *
 * @param  {Object}   currentUser 	Object representing the current user
 * @param  {String}   contentId   	Content identifier
 * @param  {Function} callback    	Standard callback function
 */
var deleteLoodle = exports.deleteLoodle = function (ctx, currentUser, contentId, callback) {

    async.parallel({
        token: 		async.apply(UserDAO.getToken, currentUser.id),
        loodleId: 	async.apply(LoodleDAO.getLoodleId, contentId),
    }, function (err, results) {
        if (err) { return callback(err); }
        LoodleDAO.deleteLoodle(ctx, results.token, results.loodleId, callback);
    });
};

/**
 * Update the members in the loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Object}   	changes   		Object with the user id as key and the role as value
 * @param  {Function} 	callback  		Standard callback function
 */
var updateMembers = exports.updateMembers = function (ctx, loodleId, changes, callback) {

    // No changes
    if (Object.keys(changes).length === 0)
        return callback();

    var currentUser = ctx.user();
    var currentUserToken;

    // parallel
    async.parallel({
        getToken: function (done) {
            UserDAO.getToken(currentUser.id, function (err, token) {
                if (err) return done(err);

                currentUserToken = token;
                return done();
            });

        },
        obtentionGroupsMembers: function (done) {
            var groups = {};

            // We get the group ids and the roles associated
            for(var id in changes) {
                if (util.isGroupId(id)) {
                    groups[id] = changes[id];
                }
            }

            // Purge the changes of the group ids
            for (var id in groups) {
                delete changes[id];
            }

            getGroupsMembers(ctx, groups, function (err, groupsMembers) {
                if (err) return done(err);

                // Add the groups members to the additional members of the loodle
                for (var id in groupsMembers) {
                    // If a member of groups has also been explicitely invited,
                    // we keep the "higher" role for him/her
                    if (id in changes) {
                        if (groupsMembers[id] === 'manager' || changes[id] === 'manager') {
                            changes[id] = 'manager';
                        }
                        else {
                            changes[id] = 'viewer';
                        }
                    }
                    else {
                        // We do not include the current user in the groups update
                        if (!(id === currentUser.id)) {
                            changes[id] = groupsMembers[id];
                        }
                    }
                }

                return done(null, groupsMembers);
            });

        }
    }, function (err) {
        if (err) return callback(err);

        async.forEachOf(changes, function (role, userId, done) {
            updateMember(ctx, loodleId, userId, role, currentUserToken, done);
        }, callback);

    });

};


/**
 * Update the member of the loodle
 *
 * @param ctx
 * @param contentId
 * @param userId
 * @param currentUserToken
 * @param callback
 */
var updateMember = function (ctx, contentId, userId, role, currentUserToken, callback) {

    var loodleId;

    async.series({
        // Get loodle id from the content id
        getLoodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, function (err, data) {
                loodleId = data;
                return done(err, data);
            });
        },
        updateMember: function (done) {
            _updateMember(ctx, contentId, loodleId, userId, role, currentUserToken, done);
        }
        // OAE handles the rest of the update
    }, callback);

};

var _updateMember = function (ctx, contentId, loodleId, userId, role, currentUserToken, callback) {

    // The user was removed from the loodle
    if (!role) {
        // Check if the user has another access to the loodle
        userHasAnotherParticipationAccess(ctx, contentId, userId, function (err, hasAnotherParticipationAccess) {
            if (err) return callback(err);
            if (hasAnotherParticipationAccess) return callback();

            LoodleDAO.removeUser(ctx, loodleId, userId, currentUserToken, callback);
        });
    }
    // The user was either added to the loodle or its status has been updated
    else {
        async.series({
            // Create the user mirror account in the loodle application if needed
            createMirrorAccountIfNeeded: async.apply(UserDAO.createUserIfNeeded, ctx, userId),
            // If the user is not already in the loodle, associate him
            associateUserToLoodleIfNeeded: function (done) {
                LoodleDAO.addUserIfNeeded(ctx, loodleId, userId, currentUserToken, done);
            }
        }, callback)
    }

}

var userHasAnotherParticipationAccess = function (ctx, contentId, userId, callback) {

    var hasAnotherParticipationAccess = false;

    // Check if the user still has access to the document
    ContentAPI.getContent(ctx, contentId, function (err, content) {
        if (err && err.code === 401 && err.msg === 'The current user does not have access to this resource') {
            return callback(null, hasAnotherParticipationAccess);
        }
        else if (err) {
            return callback(err);
        }

        // The user still has an access to the loodle, check if this is through a folder or not
        ContentAPI.getContentMembersLibrary(ctx, contentId, 0, 1000, function (err, members) {
            if (err) return callback(err);

            // Possible improvement : stop the flow at the moment the user id we're looking for is found
            var memberIds = _.pluck(_.pluck(members, 'profile'), 'id');
            async.each(memberIds, function (memberId, done) {
                if (util.isUserId(memberId)) {
                    if (memberId === userId) hasAnotherParticipationAccess = true;
                    return done();
                }
                else if(util.isGroupId(memberId)) {
                    getGroupMemberIds(ctx, memberId, function (err, groupMemberIds) {
                        if (_.contains(groupMemberIds, userId)) hasAnotherParticipationAccess = true;
                        return done();
                    });
                }
                else {
                    return callback({ 'code': 400, 'msg': 'A valid member id must be specified' });
                }
            }, function (err) {
                if (err) return callback(err);
                return callback(null, hasAnotherParticipationAccess);
            });
        });
    });

};

/**
 * Add a schedule to the specified loodle
 *
 * @param 	{Context}   ctx       		Standard context object containing the current user and the current tenant
 * @param 	{String}   	contentId 		Content identifier
 * @param 	{Object}   	schedule  		Schedule object
 * @param 	{Function} 	callback  		Standard callback function
 */
exports.addSchedule = function (ctx, loodleId, schedule, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.addSchedule, ctx, loodleId, schedule, currentUser.locale)
    ], callback);

};

/**
 * Delete a schedule to the specified loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	loodleId   		Loodle identifier
 * @param  {String}   	scheduleId 		Schedule identifier
 * @param  {Function} 	callback   		Standard callback function
 */
exports.deleteSchedule = function (ctx, loodleId, scheduleId, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.deleteSchedule, ctx, loodleId, scheduleId)
    ], callback);

};

/**
 * Update the votes of a user in a loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {Object}   	votes    		Vote object : vote id as key, vote as value
 * @param  {Function} callback 			Standard callback function
 */
exports.updateVotes = function (ctx, votes, loodleId, callback) {

    var currentUser = ctx.user();

    // Public user updating his/her votes
    if (!currentUser) {
        LoodleDAO.updatePublicVotes(ctx, loodleId, votes, callback);
    }
    else {
        UserDAO.getToken(currentUser.id, function (err, token) {
            LoodleDAO.updateVotes(ctx, token, loodleId, votes, callback);
        });
    }

};

/**
 * Emit a notification saying that the loodle's schedules has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateScheduleNotification = function (ctx, contentId, callback) {

    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err)
            return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_LOODLE_SCHEDULES, ctx, contentObj);
        return callback();
    });

};

/**
 * Emit a notification saying that the loodle's votes has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateVoteNotification = function (ctx, contentId, callback) {

    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err) return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_LOODLE_VOTES, ctx, contentObj);
        return callback();
    });

};

exports.getData = function (ctx, loodleId, callback) {

    var currentUser = ctx.user()

    if (currentUser) {
        async.waterfall([
            async.apply(UserDAO.getToken, currentUser.id),
            async.apply(LoodleDAO.get, ctx, loodleId)
        ], callback);
    }
    else {
        LoodleDAO.getPublicLoodleData(ctx, loodleId, callback);
    }

};

exports.addMemberWithVotes = function (ctx, loodleId, firstName, lastName, votes, callback) {
    votes = JSON.parse(votes);
    LoodleDAO.addMemberWithVotes(ctx, loodleId, firstName, lastName, votes, callback);
};

// Private functions ============================================
