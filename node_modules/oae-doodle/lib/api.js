// Module dependencies
var http = require('http');
var querystring = require('querystring');
var log = require('oae-logger').logger('oae-doodle-rest');
var async = require('async');

var ContentDAO = require('../../oae-content/lib/internal/dao');
var ContentConstants = require('../../oae-content/lib/constants').ContentConstants;

var EmitterAPI = require('oae-emitter');

var userAPI = require('../../oae-principals/lib/api.user');

var LoodleDAO = require('./internal/dao').doodles;
var UserDAO = require('./internal/dao').users;

var LoodleAPI = new EmitterAPI.EventEmitter();

var getUser = exports.getUser = function (ctx, userId, callback) {

    async.waterfall([
        // Get user token
        function getUserToken (done) {
            UserDAO.getToken(userId, done);
        },
        // Get user informations from its mirror account in the loodle application
        function getUserInfo (token, done) {
            UserDAO.get(ctx, token, done);
        }
    ], callback);

};

/**
 *
 * Create a loodle in the loodle application
 *
 * @param  {Context}  ctx       		 Standard context object containing the current user and the current tenant
 * @param  {String}   contentId          Id matching the loodle id which will be created
 * @param  {String}   name               Name of the loodle
 * @param  {String}   description        Description of the loodle
 * @param  {Object}   additionalMembers  Members to add to the loodle additionnaly to the current user
 * @param  {Function} callback           Standard callback function
 */
exports.create = function (ctx, currentUser, contentId, name, description, additionalMembers, callback) {

    var loodleId,
        token;

    async.series([
        // Create the current user mirror account in the loodle application if needed
        function createCurrentUserMirrorAccountIfNeeded (end) {
            UserDAO.createUserIfNeeded(ctx, currentUser.id, end);
        },
        // Get the current user token to communicate with the loodle application
        function getCurrentUserToken (end) {
            UserDAO.getToken(currentUser.id, function (err, data) {
                token = data;
                return end(err, data);
            });
        },
        // Call to the loodle api to create the loodle
        function createLoodle (end) {
            LoodleDAO.createLoodle(ctx, token, name, description, function (err, data) {
                if (err) return end(err);

                loodleId = data;
                return end();
            });
        },
        // Save in db the matching contentId - loodleId
        function saveMatch (end) {
            LoodleDAO.saveMatch(contentId, loodleId, end);
        },
        // Add the additional members to the loodle
        function addMembers (end) {

            // For all additionnal members
            // Creation of the mirror account in the loodle application if not known
            // Add the user to the loodle
            async.forEachOf(additionalMembers, function (value, userId, done) {

                // The current user already have a current user because we communicate with
                // the loodle application with its token
                if (userId === currentUser.id)
                    return done();

                async.series({
                    createUser: function (finish) {
                        UserDAO.createUserIfNeeded(ctx, userId, finish);
                    },
                    addUserToLoodle: function (finish) {
                        LoodleDAO.addUserToLoodle(ctx, token, loodleId, userId, finish);
                    }
                }, done);

            }, end);

        }
    ], callback);

};

exports.getFromContentId = function (ctx, currentUser, contentId, callback) {

    UserDAO.getToken(currentUser.id, function (err, token) {
        if (err) return callback(err);

        async.waterfall([
            // Get loodleId from ContentId
            function (end) {
                LoodleDAO.getLoodleId(contentId, end);
            },
            // Get loodle data using the loodleId
            function (loodleId, end) {
                LoodleDAO.getLoodleData(ctx, token, loodleId, end);
            }
        ], callback);

    });

};

/**
 * Delete the loodle in the loodle application
 *
 * @param  {Object}   currentUser 	Object representing the current user
 * @param  {String}   contentId   	Content identifier
 * @param  {Function} callback    	Standard callback function
 */
exports.delete = function (ctx, currentUser, contentId, callback) {

    async.parallel({
        token: 		async.apply(UserDAO.getToken, currentUser.id),
        loodleId: 	async.apply(LoodleDAO.getLoodleId, contentId),
    }, function (err, results) {
        if (err) { return callback(err); }
        LoodleDAO.deleteLoodle(ctx, results.token, results.loodleId, callback);
    });
};

/**
 * Update the members in the loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Object}   	changes   		Object with the user id as key and the role as value
 * @param  {Function} 	callback  		Standard callback function
 */
exports.updateMembers = function (ctx, loodleId, changes, callback) {

    // No changes
    if (Object.keys(changes).length === 0)
        return callback();

    async.waterfall([
        // Get the current user token
        async.apply(UserDAO.getToken, ctx.user().id),
        function (currentUserToken, done) {

            async.forEachOf(changes, function (role, userId, end) {
                updateMember(ctx, loodleId, userId, role, currentUserToken, end);
            }, done);

        }
    ], callback);

};

/**
 * Update the member of the loodle
 *
 * @param ctx
 * @param contentId
 * @param userId
 * @param currentUserToken
 * @param callback
 */
var updateMember = function (ctx, contentId, userId, role, currentUserToken, callback) {

    var loodleId;

    async.series({
        // Get loodle id from the content id
        getLoodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, function (err, data) {
                loodleId = data;
                return done(err, data);
            });
        },
        updateMember: function (done) {
            _updateMember(ctx, loodleId, userId, role, currentUserToken, done);
        }
        // OAE handles the rest of the update
    }, callback);

};

var _updateMember = function (ctx, loodleId, userId, role, currentUserToken, callback) {

    // The user was removed from the loodle
    if (!role) {
        LoodleDAO.removeUser(ctx, loodleId, userId, currentUserToken, callback);
    }
    // The user was either added to the loodle or its status has been updated
    else {
        async.series({
            // Create the user mirror account in the loodle application if needed
            createMirrorAccountIfNeeded: async.apply(UserDAO.createUserIfNeeded, ctx, userId),
            // If the user is not already in the loodle, associate him
            associateUserToLoodleIfNeeded: function (done) {
                LoodleDAO.addUserIfNeeded(ctx, loodleId, userId, currentUserToken, done);
            }
        }, callback)
    }

}

/**
 * Add a schedule to the specified loodle
 *
 * @param 	{Context}   ctx       		Standard context object containing the current user and the current tenant
 * @param 	{String}   	contentId 		Content identifier
 * @param 	{Object}   	schedule  		Schedule object
 * @param 	{Function} 	callback  		Standard callback function
 */
exports.addSchedule = function (ctx, loodleId, schedule, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.addSchedule, ctx, loodleId, schedule, currentUser.locale)
    ], callback);

};

/**
 * Delete a schedule to the specified loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	loodleId   		Loodle identifier
 * @param  {String}   	scheduleId 		Schedule identifier
 * @param  {Function} 	callback   		Standard callback function
 */
exports.deleteSchedule = function (ctx, loodleId, scheduleId, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.deleteSchedule, ctx, loodleId, scheduleId)
    ], callback);

};

/**
 * Update the votes of a user in a loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {Object}   	votes    		Vote object : schedule id as key, vote as value
 * @param  {Function} callback 			Standard callback function
 */
exports.updateVotes = function (ctx, votes, loodleId, callback) {

    var currentUser = ctx.user();

    UserDAO.getToken(currentUser.id, function (err, token) {

        LoodleDAO.updateVotes(ctx, token, loodleId, votes, function (err) {
            if (err)
                return callback(err);

            return callback(err);

        });

    });

};

/**
 * Emit a notification saying that the loodle's schedules has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateScheduleNotification = function (ctx, contentId, callback) {

    var ContentAPI = require('oae-content');
    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err)
            return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_DOODLE_SCHEDULES, ctx, contentObj);
        return callback();
    });

};

/**
 * Emit a notification saying that the loodle's votes has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateVoteNotification = function (ctx, contentId, callback) {

    var ContentAPI = require('oae-content');
    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err)
            return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_DOODLE_VOTES, ctx, contentObj);
        return callback();
    });

};

exports.getData = function (ctx, loodleId, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.get, ctx, loodleId)
    ], callback);

};

// Private functions ============================================

/**
 * Get the token to communicate with the loodle application
 *
 * @param  {Object}   user     	User object
 * @param  {Function} callback 	Standard callback function
 */
function getToken (user, callback) {

    UserDAO.hasLoodleAccount(user.id, function (err, isInDb) {
        if (err)
            return callback(err);

        if (!isInDb)
            return callback(null, false);

        return UserDAO.getToken(user.id, callback);
    });

}
