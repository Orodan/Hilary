// Module dependencies
var _ = require('underscore');
var http = require('http');
var querystring = require('querystring');
var log = require('oae-logger').logger('oae-loodle-api');
var async = require('async');

var FoldersDAO = require('../../oae-folders/lib/internal/dao');
var LoodleDAO = require('./internal/dao').loodles;
var UserDAO = require('./internal/dao').users;
var ContentDAO = require('../../oae-content/lib/internal/dao');

var ContentConstants = require('../../oae-content/lib/constants').ContentConstants;
var PrincipalsConstants = require('../../oae-principals/lib/constants').PrincipalsConstants;
var AuthzConstants = require('oae-authz/lib/constants').AuthzConstants;

var userAPI = require('../../oae-principals/lib/api.user');
var groupAPI = require('../../oae-principals/lib/api.group');
var EmitterAPI = require('oae-emitter');
var GroupAPI = require('../../oae-principals/lib/api.group');
var PrincipalsUtil = require('../../oae-principals/lib/util');
var LibraryAPI = require('oae-library');
var AuthzAPI = require('oae-authz');
var ContentMembersLibrary = require('../../oae-content/lib/internal/membersLibrary');
var PrincipalsMembersLibrary = require('../../oae-principals/lib/libraries/members');
var LoodleAPI = new EmitterAPI.EventEmitter();

var PrincipalsEmitter = require('../../oae-principals/lib/internal/emitter');

var util = require('../../oae-authz/lib/util');
var ContentUtil = require('../../oae-content/lib/internal/util');

PrincipalsEmitter.when(PrincipalsConstants.events.DELETED_GROUP, function (ctx, group, callback) {

    // Check if the group library has somme loodles, otherwise we have nothing to do
    getGroupLoodles(ctx, group, function (err, contents) {
        if (err) return callback(err);
        if (!contents.length) return callback();

        removeGroupMembers(ctx, group, contents, callback);
    });

});

// Update has been made on group members
PrincipalsEmitter.when(PrincipalsConstants.events.UPDATED_GROUP_MEMBERS, function (ctx, group, oldGroup, memberChangeInfo, opts, callback) {

    // Check if the group library has some loodles, otherwise we have nothing to do
    getGroupLoodles(ctx, group, function (err, contents) {
        if (err) return callback(err);
        if (!contents.length) return callback();

        setGroupMembers(ctx, contents, memberChangeInfo, callback);
    });

});

var removeGroupMembers = function (ctx, group, contents, callback) {

    // Get the token of the current user
    UserDAO.getToken(ctx.user().id, function (err, token) {
        if (err) return callback(err);

        // We can't get easily the group members as the group is already deleted at this point.
        // To update the loodle members, we get all the users who have access to it in OAE,
        // we get all the users who have access to it in the loodle application, and if one
        // of them has access to it in the loodle application but not in OAE, it means he/she
        // was a member of the group who lost access to it, so we remove him/her

        async.each(contents, function (content, done) {
            LoodleDAO.getLoodleId(content.id, function (err, loodleId) {
                if (err) return callback(err);

                // Get all the users who have access to the loodle in OAE
                getLoodleMembers(ctx, content, group.id, function (err, loodleMembers) {
                    if (err) return done(err);

                    var loodleMemberIds = [];

                    async.each(loodleMembers, function (loodleMember, finish) {
                        UserDAO.getToken(loodleMember, function (err, loodleMemberToken) {
                            if (err) return finish(err);

                            UserDAO.get(ctx, loodleMemberToken, function (err, loodleMemberData) {
                                if (err) return finish(err);

                                loodleMemberIds.push(loodleMemberData.id);
                                return finish();
                            });
                        });
                    }, function (err) {
                        if (err) return done(err);

                        LoodleDAO.getLoodleData(ctx, token, loodleId, function (err, loodle) {
                            if (err) return done(err);

                            var loodleUserIds = _.pluck(loodle.users, 'id');
                            var diffUsers = _.difference(loodleUserIds, loodleMemberIds);

                            async.each(function (user, finish) {
                                LoodleDAO.removeUser(ctx, loodleId, userId, token, finish);
                            }, done);
                        });
                    });
                });
            });
        }, callback);
    });

};

var getLoodleMembers = function (ctx, content, groupId, callback) {

    // Determine if and how the current user should access the content members library
    LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, content.id, content, function(err, hasAccess, visibility) {
        if (err) return callback(err);
        if (!hasAccess) return callback({'code': 401, 'msg': 'You are not authorized to access the members of this content item'});

        // Get the members of the content item from the members library
        ContentMembersLibrary.list(content, visibility, {'start': 0, 'limit': null}, function(err, memberIds, nextToken) {
            if (err) return callback(err);
            if (_.isEmpty(memberIds)) return callback(null, [], nextToken);

            async.each(memberIds, function (memberId, done) {
                if (!(util.isGroupId(memberId))) return done();
                if (memberId === groupId) {
                    memberIds = _.without(memberIds, memberId);
                    return done();
                }

                // Check if the group has not been deleted (OAE does not remove the content access of deleted group)
                GroupAPI.getGroup(ctx, memberId, function (err, group) {
                    if (err) return done(err);
                    if (group.deleted) return done();

                    // We get all of its members
                    getGroupMembers(ctx, memberId, function (err, groupMembers) {

                        // Delete the group id from the member ids
                        memberIds = _.without(memberIds, memberId);

                        // Add the members of the group to the member ids (if they are not already in)
                        groupMembers.forEach(function (userId) {
                            if (!(_.contains(memberIds, userId))) {
                                memberIds.push(userId);
                            }
                        });

                        return done();
                    });
                });
            }, function (err) {
                if (err) return callback(err);
                return callback(null, memberIds);
            });
        });
    });

};

/**
 * Get all the loodle type contents inside of the group library
 *
 * @param ctx
 * @param group
 * @param callback
 */
var getGroupLoodles = function (ctx, group, callback) {

    // Determine which library visibility we need to fetch
    LibraryAPI.Authz.resolveTargetLibraryAccess(ctx, group.id, group, function(err, hasAccess, visibility) {
        if (err) return callback(err);
        if (!hasAccess) return callback({'code': 401, 'msg': 'You do not have access to this library'});

        ContentDAO.Content.getContentLibraryItems(group.id, visibility, 0, null, function(err, contentObjects) {
            if (err) return callback(err);

            // Filter only the loodle contents
            contentObjects = _.filter(contentObjects, function (content) {
                return content.resourceSubType === 'loodle';
            });

            return callback(null, contentObjects);
        });
    });

};

/**
 * Apply the updates about the group members to the loodles
 *
 * @param contents
 * @param memberChangeInfo
 * @param callback
 */
var setGroupMembers = function (ctx, contents, memberChangeInfo, callback) {

    // Get the token of the current user
    UserDAO.getToken(ctx.user().id, function (err, token) {
        if (err) return callback(err);

        async.parallel({
            added: function (done) {
                if (memberChangeInfo.members.added.length === 0)
                    return done();

                addUsersToLoodles(ctx, contents, memberChangeInfo, token, done);
            },
            removed: function (done) {
                if (memberChangeInfo.members.removed.length === 0)
                    return done();

                removeUsersFromLoodles(ctx, contents, memberChangeInfo, token, done);
            }
        }, callback);
    });

};

/**
 * Add the users to the loodles
 *
 * @param contents
 * @param memberChangeInfo
 * @param token
 * @param callback
 */
var addUsersToLoodles = function (ctx, contents, memberChangeInfo, token, callback) {

    // for each user added
    async.each(memberChangeInfo.members.added, function (addedMember, done) {
        // for each loodle
        async.each(contents, function (content, finish) {

            LoodleDAO.getLoodleId(content.id, function (err, loodleId) {
                if (err) return finish(err);

                // check if the user is already participating to the loodle
                userIsInLoodle(ctx, addedMember.id, loodleId, function (err, isInLoodle) {
                    if (err) return finish(err);

                    // if it is the case, we do nothing
                    if(isInLoodle) {
                        return finish();
                    }

                    // if it is not the case, add the user
                    addUser(ctx, addedMember.id, token, loodleId, finish);
                });
            });

        }, done);
    }, callback);

};

/**
 * Remove the users to the loodles
 *
 * @param loodles
 * @param users
 * @param callback
 */
var removeUsersFromLoodles = function (ctx, contents, memberChangeInfo, token, callback) {

    // for each user removed
    async.each(memberChangeInfo.members.removed, function (removedMember, done) {
        // for each loodle
        async.each(contents, function (content, finish) {

            ContentDAO.Content.getAllContentMembers(content.id, function (err, members) {
                if (err) return finish(err);

                var isInMembers = _.find(members, function (member) {
                    if (member.id === removedMember.id) {
                        return true;
                    }
                });

                // if the user removed from the groupe was explicitely invated in the loodle
                // we don't removed him/her
                if(isInMembers) {
                    return finish();
                }

                // if it is not the case, remove the user from the loodle
                LoodleDAO.getLoodleId(content.id, function (err, loodleId) {
                    if (err) return finish(err);

                    LoodleDAO.removeUser(ctx, loodleId, removedMember.id, token, callback);
                });

            });

        }, done);
    }, callback);

};

var getGroupMembers = function (ctx, groupId, callback) {

    var groupMembers = [];

    groupAPI.getMembersLibrary(ctx, groupId, 0, null, function (err, data) {
        if (err) return callback(err);

        data.forEach(function (member) {
            groupMembers.push(member.profile.id);
        });

        return callback(null, groupMembers);
    });

};

var getGroupsMembers = function (ctx, groups, callback) {

    var groupsMembers = {};

    async.forEachOf(groups, function (role, groupId, done) {
        getGroupMemberIds(ctx, groupId, function (err, groupMembers) {
            if (err) return done(err);

            groupMembers.forEach(function (id) {
                // If the user was already in another group
                if (id in groupsMembers) {
                    if (groupsMembers[id] === 'manager' || role === 'manager') {
                        groupsMembers[id] = 'manager';
                    }
                    else {
                        groupsMembers[id] = 'viewer';
                    }
                }
                else {
                    groupsMembers[id] = role;
                }
            });

            return done();
        });
    }, function (err) {
        if (err) return callback(err);

        return callback(null, groupsMembers);
    });

};

/**
 * Update the loodle category
 *
 * @param ctx
 * @param contentId
 * @param callback
 */
var updateVisibility = exports.updateVisibility = function (ctx, contentId, visibility, callback) {

    var currentUserToken,
        loodleId;

    async.series({
        getToken: function (done) {
            UserDAO.getToken(ctx.user().id, function (err, token) {
                if (err) return done(err);

                currentUserToken = token;
                return done();
            })
        },
        getLoodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, function (err, data) {
                if (err) return done(err);

                loodleId = data;
                return done();
            });
        },
        update: function (done) {
            LoodleDAO.updateVisibility(ctx, currentUserToken, loodleId, visibility.visibility, done);
        }
    }, callback);

}

/**
 * Check if a user participate to a specified loodle
 *
 * @param userId
 * @param loodleId
 * @param callback
 */
var userIsInLoodle = exports.userIsInLoodle = function (ctx, userId, loodleId, callback) {

    UserDAO.hasLoodleAccount(userId, function (err, hasLoodleAccount) {
        if (err) return callback(err);

        // The user does not have a mirror acount in the loodle application
        if (!hasLoodleAccount) return callback(null, false);

        async.waterfall([
            // Get user token
            function getUserToken (done) {
                UserDAO.getToken(userId, done);
            },

            // Check if the user is already in the loodle
            function checkIfInLoodle (token, done) {
                UserDAO.isInLoodle(ctx, userId, loodleId, token, done);
            }
        ], callback);
    });

};

var getUser = exports.getUser = function (ctx, userId, callback) {

    async.waterfall([
        // Get user token
        function getUserToken (done) {
            UserDAO.getToken(userId, done);
        },
        // Get user informations from its mirror account in the loodle application
        function getUserInfo (token, done) {
            UserDAO.get(ctx, token, done);
        }
    ], callback);

};

/**
 * Add an user to a loodle
 *
 * @param ctx
 * @param userId
 * @param callback
 */
var addUserIfNeeded = exports.addUserIfNeeded = function (ctx, contentId, userId, callback) {

    async.parallel({
        loodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, done);
        },
        token: function (done) {
            UserDAO.getToken(userId, done);
        }
    }, function (err, data) {
        if (err) return callback(err);

        LoodleDAO.addUserIfNeeded(ctx, data.loodleId, userId, data.token, callback);
    });

};

/**
 * Get or create a mirror account for an user
 *
 * @param ctx
 * @param userId
 * @param callback
 */
var getOrCreateUser = exports.getOrCreateUser = function (ctx, userId, callback) {

    UserDAO.hasLoodleAccount(userId, function (err, hasLoodleAccount) {
        if (err) return callback(err);

        if (hasLoodleAccount) {
            getUser(ctx, userId, callback);
        }
        else {
            UserDAO.createLoodleAccount(ctx, ctx.user(), function (err) {
                if (err) return callback(err);
                getUser(ctx, userId, callback);
            });
        }
    });

};

/**
 * Create a loodle account for every member of the loodle (if they don't already have one)
 * @param folderId
 * @param callback
 */
var createAccountForFolderMembers = function (ctx, folderId, callback) {

    // Get the folder from storage to use for permission checks
    FoldersDAO.getFolder(folderId, function(err, folder) {

        AuthzAPI.getAuthzMembers(folder.groupId, null, 1000, function(err, members, nextToken) {
            if (err) return callback(err);

            async.each(members, function (member, done) {
                // The member is an user
                if (util.isUserId(member.id)) {
                    UserDAO.createUserIfNeeded(ctx, member.id, done);
                }
                // The member is a group
                else if (util.isGroupId(member.id)) {
                    getGroupMemberIds(ctx, member.id, function (err, groupMemberIds) {
                        if (err) return done(err);

                        async.each(groupMemberIds, function (groupMemberId, finish) {
                            UserDAO.createUserIfNeeded(ctx, groupMemberId, finish);
                        }, done);
                    });
                }
                // Invalid member id
                else {
                    return done({code: 500, msg: 'Invalid member id'});
                }

            }, callback);
        });

    });

};

/**
 *
 * Create a loodle in the loodle application
 *
 * @param  {Context}  ctx       		 Standard context object containing the current user and the current tenant
 * @param  {String}   contentId          Id matching the loodle id which will be created
 * @param  {String}   name               Name of the loodle
 * @param  {String}   description        Description of the loodle
 * @param  {Object}   additionalMembers  Members to add to the loodle additionnaly to the current user
 * @param  {Function} callback           Standard callback function
 */
exports.create = function (ctx, currentUser, contentId, name, description, visibility, additionalMembers, folders, callback) {

    var cloneAdditionalMembers = {};
    var loodleId,
        token;

    async.series([
        // Even if members of a folder only have a read only access if the loodle is created inside
        // a folder, we still neeed to create a mirror account for them (if they don't already have
        // one), otheriwe they will not be able to access the loodle data
        function createMirrorAccountForFoldersMembers (end) {
            async.each(folders, function (folderId, finish) {
                createAccountForFolderMembers(ctx, folderId, finish);
            }, end);
        },
        function cloningAdditionalMembers (end) {
            async.forEachOf(additionalMembers, function (value, key, finish) {
                cloneAdditionalMembers[key] = value;
                return finish();
            }, end);
        },
        // Create the current user mirror account in the loodle application if needed
        function createCurrentUserMirrorAccountIfNeeded (end) {
            UserDAO.createUserIfNeeded(ctx, currentUser.id, end);
        },
        // Get the current user token to communicate with the loodle application
        function getCurrentUserToken (end) {
            UserDAO.getToken(currentUser.id, function (err, data) {
                token = data;
                return end(err, data);
            });
        },
        // Call to the loodle api to create the loodle
        function createLoodle (end) {
            LoodleDAO.createLoodle(ctx, token, name, description, visibility, function (err, data) {
                if (err) return end(err);

                // Delete the current user from the additional members as he/she is already associated
                // with the new loodle created
                delete cloneAdditionalMembers[currentUser.id]

                loodleId = data;
                return end();
            });
        },
        // Save in db the matching contentId - loodleId
        function saveMatch (end) {
            LoodleDAO.saveMatch(contentId, loodleId, end);
        },
        function getGroupUsers (end) {
            async.forEachOf(cloneAdditionalMembers, function (role, id, finish) {
                if(!util.isGroupId(id)) {
                    return finish();
                }

                getGroupMemberIds(ctx, id, function (err, groupMemberIds) {
                    if (err) return finish(err)

                    groupMemberIds.forEach(function (groupMemberId) {
                        if (!(groupMemberId in cloneAdditionalMembers) && groupMemberId != currentUser.id) {
                            cloneAdditionalMembers[groupMemberId] = 'manager';
                        }
                    });

                    delete cloneAdditionalMembers[id];

                    return finish();
                });
            }, end);
        },
        function addMembers (end) {
            addUsers(ctx, cloneAdditionalMembers, token, loodleId, end);
        }
    ], callback);

};

/**
 * Recursive function that get all the group members. If a group is member of
 * another group, we get all its users.
 *
 * @param ctx
 * @param groupId
 * @param callback
 */
var getGroupMemberIds = function (ctx, groupId, callback) {

    var users = [];


    // Instead of using the GroupAPI.getMembersLibrary, we use the PrincipalsMembersLibrary to avoid having
    // insufficient privilege when getting the group member ids
    PrincipalsMembersLibrary.list({id: groupId}, AuthzConstants.visibility.PRIVATE, {'start': 0, 'limit': 1000}, function(err, memberEntries, nextToken) {
        if (err) return callback(err);

        var memberIds = _.pluck(memberEntries, 'id');
        async.each(memberIds, function (memberId, done) {
            if (!util.isGroupId(memberId)) {
                users.push(memberId);
                return done();
            }

            getGroupMemberIds(ctx, memberId, function (err, subgroupMembers) {
                if (err) return done(err);

                users = _.union(users, subgroupMembers);
                return done();
            });

        }, function (err) {
            if (err) return callback(err);

            return callback(null, users);
        });

    });

};



/**
 * Add users to a loodle
 *
 * @param ctx
 * @param additionalMembers
 * @param token
 * @param loodleId
 * @param callback
 */
var addUsers = function (ctx, additionalMembers, token, loodleId, callback) {

    async.forEachOf(additionalMembers, function (role, id, done) {
        addUser(ctx, id, token, loodleId, done);
    }, callback);

};

/**
 * Add a user to a loodle
 *
 * @param ctx
 * @param userId
 * @param token
 * @param loodleId
 * @param callback
 */
var addUser = function (ctx, userId, token, loodleId, callback) {

    async.series({
        createUser: function (done) {
            UserDAO.createUserIfNeeded(ctx, userId, done);
        },
        addUserToLoodle: function (done) {
            LoodleDAO.addUserToLoodle(ctx, token, loodleId, userId, done);
        }
    }, callback);

};

exports.getFromContentId = function (ctx, currentUser, contentId, callback) {

    UserDAO.getToken(currentUser.id, function (err, token) {
        if (err) return callback(err);

        async.waterfall([
            // Get loodleId from ContentId
            function (end) {
                LoodleDAO.getLoodleId(contentId, end);
            },
            // Get loodle data using the loodleId
            function (loodleId, end) {
                LoodleDAO.getLoodleData(ctx, token, loodleId, end);
            }
        ], callback);

    });

};

exports.getPublicLoodleFromContentId = function (ctx, contentId, callback) {

    async.waterfall([
        // Get loodleId from ContentId
        function (end) {
            LoodleDAO.getLoodleId(contentId, end);
        },
        // Get loodle data using the loodleId
        function (loodleId, end) {
            LoodleDAO.getPublicLoodleData(ctx, loodleId, end);
        }
    ], callback);

};

/**
 * Delete the loodle in the loodle application
 *
 * @param  {Object}   currentUser 	Object representing the current user
 * @param  {String}   contentId   	Content identifier
 * @param  {Function} callback    	Standard callback function
 */
exports.delete = function (ctx, currentUser, contentId, callback) {

    async.parallel({
        token: 		async.apply(UserDAO.getToken, currentUser.id),
        loodleId: 	async.apply(LoodleDAO.getLoodleId, contentId),
    }, function (err, results) {
        if (err) { return callback(err); }
        LoodleDAO.deleteLoodle(ctx, results.token, results.loodleId, callback);
    });
};

/**
 * Update the members in the loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Object}   	changes   		Object with the user id as key and the role as value
 * @param  {Function} 	callback  		Standard callback function
 */
exports.updateMembers = function (ctx, loodleId, changes, callback) {

    // No changes
    if (Object.keys(changes).length === 0)
        return callback();

    var currentUser = ctx.user();
    var currentUserToken;

    async.parallel({
        getToken: function (done) {

            UserDAO.getToken(currentUser.id, function (err, token) {
                if (err) return done(err);

                currentUserToken = token;
                return done();
            });

        },
        getGroupsMembers: function (done) {

            var groups = {};

            // We get the group ids and the roles associated
            for(var id in changes) {
                if (util.isGroupId(id)) {
                    groups[id] = changes[id];
                }
            }

            // Purge the changes of the group ids
            for (var id in groups) {
                delete changes[id];
            }

            getGroupsMembers(ctx, groups, function (err, groupsMembers) {
                if (err) return done(err);

                // Add the groups members to the additional members of the loodle
                for (var id in groupsMembers) {
                    // If a member of groups has also been explicitely invited,
                    // we keep the "higher" role for him/her
                    if (id in changes) {
                        if (groupsMembers[id] === 'manager' || changes[id] === 'manager') {
                            changes[id] = 'manager';
                        }
                        else {
                            changes[id] = 'viewer';
                        }
                    }
                    else {
                        // We do not include the current user in the groups update
                        if (!(id === currentUser.id)) {
                            changes[id] = groupsMembers[id];
                        }
                    }
                }

                return done(null, groupsMembers);
            });

        }
    }, function (err) {
        if (err) return callback(err);

        async.forEachOf(changes, function (role, userId, done) {
            updateMember(ctx, loodleId, userId, role, currentUserToken, done);
        }, callback);

    });

};


/**
 * Update the member of the loodle
 *
 * @param ctx
 * @param contentId
 * @param userId
 * @param currentUserToken
 * @param callback
 */
var updateMember = function (ctx, contentId, userId, role, currentUserToken, callback) {

    var loodleId;

    async.series({
        // Get loodle id from the content id
        getLoodleId: function (done) {
            LoodleDAO.getLoodleId(contentId, function (err, data) {
                loodleId = data;
                return done(err, data);
            });
        },
        updateMember: function (done) {
            _updateMember(ctx, loodleId, userId, role, currentUserToken, done);
        }
        // OAE handles the rest of the update
    }, callback);

};

var _updateMember = function (ctx, loodleId, userId, role, currentUserToken, callback) {

    // The user was removed from the loodle
    if (!role) {
        LoodleDAO.removeUser(ctx, loodleId, userId, currentUserToken, callback);
    }
    // The user was either added to the loodle or its status has been updated
    else {
        async.series({
            // Create the user mirror account in the loodle application if needed
            createMirrorAccountIfNeeded: async.apply(UserDAO.createUserIfNeeded, ctx, userId),
            // If the user is not already in the loodle, associate him
            associateUserToLoodleIfNeeded: function (done) {
                LoodleDAO.addUserIfNeeded(ctx, loodleId, userId, currentUserToken, done);
            }
        }, callback)
    }

}

/**
 * Add a schedule to the specified loodle
 *
 * @param 	{Context}   ctx       		Standard context object containing the current user and the current tenant
 * @param 	{String}   	contentId 		Content identifier
 * @param 	{Object}   	schedule  		Schedule object
 * @param 	{Function} 	callback  		Standard callback function
 */
exports.addSchedule = function (ctx, loodleId, schedule, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.addSchedule, ctx, loodleId, schedule, currentUser.locale)
    ], callback);

};

/**
 * Delete a schedule to the specified loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	loodleId   		Loodle identifier
 * @param  {String}   	scheduleId 		Schedule identifier
 * @param  {Function} 	callback   		Standard callback function
 */
exports.deleteSchedule = function (ctx, loodleId, scheduleId, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(UserDAO.getToken, currentUser.id),
        async.apply(LoodleDAO.deleteSchedule, ctx, loodleId, scheduleId)
    ], callback);

};

/**
 * Update the votes of a user in a loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {Object}   	votes    		Vote object : vote id as key, vote as value
 * @param  {Function} callback 			Standard callback function
 */
exports.updateVotes = function (ctx, votes, loodleId, callback) {

    var currentUser = ctx.user();

    // Public user updating his/her votes
    if (!currentUser) {
        LoodleDAO.updatePublicVotes(ctx, loodleId, votes, callback);
    }
    else {
        UserDAO.getToken(currentUser.id, function (err, token) {
            LoodleDAO.updateVotes(ctx, token, loodleId, votes, callback);
        });
    }

};

/**
 * Emit a notification saying that the loodle's schedules has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateScheduleNotification = function (ctx, contentId, callback) {

    var ContentAPI = require('oae-content');
    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err)
            return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_LOODLE_SCHEDULES, ctx, contentObj);
        return callback();
    });

};

/**
 * Emit a notification saying that the loodle's votes has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateVoteNotification = function (ctx, contentId, callback) {

    var ContentAPI = require('oae-content');
    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err) return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_LOODLE_VOTES, ctx, contentObj);
        return callback();
    });

};

exports.getData = function (ctx, loodleId, callback) {

    var currentUser = ctx.user()

    if (currentUser) {
        async.waterfall([
            async.apply(UserDAO.getToken, currentUser.id),
            async.apply(LoodleDAO.get, ctx, loodleId)
        ], callback);
    }
    else {
        LoodleDAO.getPublicLoodleData(ctx, loodleId, callback);
    }

};

exports.addMemberWithVotes = function (ctx, loodleId, firstName, lastName, votes, callback) {
    votes = JSON.parse(votes);
    LoodleDAO.addMemberWithVotes(ctx, loodleId, firstName, lastName, votes, callback);
};

// Private functions ============================================
