// Module dependencies
var http = require('http');
var querystring = require('querystring');
var log = require('oae-logger').logger('oae-doodle-rest');
var async = require('async');

var ContentDAO = require('../../oae-content/lib/internal/dao');
var ContentConstants = require('../../oae-content/lib/constants').ContentConstants;

var EmitterAPI = require('oae-emitter');

var userAPI = require('../../oae-principals/lib/api.user');

var LoodleDAO = require('./internal/dao').doodles;
var TokenDAO = require('./internal/dao').tokens;
var UserDAO = require('./internal/dao').users;

var LoodleAPI = new EmitterAPI.EventEmitter();

var getUser = exports.getUser = function (userId, callback) {

    async.waterfall([
        // Get user token
        function getUserToken (done) {
            TokenDAO.get(userId, done);
        },
        // Get user informations from its mirror account in the loodle application
        function getUserInfo (token, done) {
            UserDAO.get(token, done);
        }
    ], callback);

};

/**
 *
 * Create a loodle in the loodle application
 *
 * @param  {Context}  ctx       		 Standard context object containing the current user and the current tenant
 * @param  {[type]}   contentId          Id matching the loodle id which will be created
 * @param  {[type]}   name               Name of the loodle
 * @param  {[type]}   description        Description of the loodle
 * @param  {[type]}   additionalMembers  Members to add to the loodle additionnaly to the current user
 * @param  {Function} callback           Standard callback function
 * @return {[type]}                      Void or error message
 */
exports.create = function (ctx, currentUser, contentId, name, description, additionalMembers, callback) {

    var loodleId;

    log().info('create');
    log().info('currentUser : ', currentUser);
    log().info('additionalMembers : ', additionalMembers);

    getToken(currentUser, function (err, token) {
        if (err)
            return callback(err);

        async.series([
            // Call to the loodle api to create the loodle
            function createLoodle (end) {
                LoodleDAO.createLoodle(token, name, description, function (err, data) {
                    if (err) return end(err);

                    loodleId = data;
                    return end();
                });
            },
            // Save in db the matching contentId - loodleId
            function saveMatch (end) {
                LoodleDAO.saveMatch(contentId, loodleId, end);
            },
            // Add the additional members to the loodle
            function addMembers (end) {

                // For all additionnal members
                // Creation of the mirror account in the loodle application if not known
                // Add the user to the loodle
                async.forEachOf(additionalMembers, function (value, userId, done) {

                    // The current user already have a current user because we communicate with
                    // the loodle application with its token
                    if (userId === currentUser.id)
                        return done();

                    async.series({
                        createUser: function (finish) {
                            UserDAO.createUserIfNeeded(ctx, userId, finish);
                        },
                        addUserToLoodle: function (finish) {
                            LoodleDAO.addUserToLoodle(currentUser, loodleId, userId, finish);
                        }
                    }, done);

                }, end);

            }
        ], callback);

    });

};

exports.get = function (currentUser, contentId, callback) {

    log().info('get');

    /**
     * Workflow :
     * --> Get token
     * --> Get loodleId from ContentId
     * --> Get loodle data using the loodleId
     */

    getToken(currentUser, function (err, token) {
        if (err)
            return callback(err);

        async.waterfall([
            // Get loodleId from ContentId
            function (end) {
                LoodleDAO.getLoodleId(contentId, end);
            },
            // Get loodle data using the loodleId
            function (loodleId, end) {
                LoodleDAO.getLoodleData(token, loodleId, end);
            }
        ], callback);

    });

};

/**
 * Delete the loodle in the loodle application
 *
 * @param  {Object}   currentUser 	Object representing the current user
 * @param  {String}   contentId   	Content identifier
 * @param  {Function} callback    	Standard callback function
 */
exports.delete = function (currentUser, contentId, callback) {

    async.parallel({
        token: 		async.apply(TokenDAO.get, currentUser.id),
        loodleId: 	async.apply(LoodleDAO.getLoodleId, contentId),
    }, function (err, results) {
        if (err) { return callback(err); }
        LoodleDAO.deleteLoodle(results.token, results.loodleId, callback);
    });
};

/**
 * Update the members in the loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Object}   	changes   		Object with the user id as key and the role as value
 * @param  {Function} 	callback  		Standard callback function
 */
exports.updateMembers = function (ctx, contentId, changes, callback) {

    // Workflow :
    // Check the changes to see if there is something to update
    // If there is :
    // Get the loodle id from the content id
    // Check if a token is already associated with the user
    // If there is --> means you have to check if this user is associated with
    // the loodle in the loodle application
    // If he is not, associate him
    // Else do nothing, oae handle the access permission by itself
    // If there is no token --> create the token for the user and associate it with the loodle

    // No changes
    if (Object.keys(changes).length === 0)
        return callback();

    // Current user data
    var currentUser = ctx.user();
    var currentToken = '';

    async.waterfall([
        // Get token of the current user
        async.apply(TokenDAO.get, currentUser.id),
        // Get loodle id from the content id
        function (token, done) {
            currentToken = token;
            LoodleDAO.getLoodleId(contentId, done);
        },
        // Apply the changes
        function (loodleId, done) {

            async.forEachOf(changes, function (role, userId, end) {

                // Get the token of the user with a change to apply
                TokenDAO.isInDb(userId, function (err, isInDb) {
                    if (err) { return end(err); }
                    // If this user is already registred in the loodle application
                    if (isInDb) {

                        var token = '';

                        async.waterfall([
                            // Get the token of the user with a change to apply
                            function getToken (finish) {
                                TokenDAO.get(userId, function (err, result) {
                                    if (err) { return finish(err); }
                                    token = result;
                                    return finish(null, result);
                                });
                            },
                            // Check if this user is already associated with the loodle
                            async.apply(UserDAO.isInLoodle, userId, loodleId),
                            function addUser (isInLoodle, finish) {
                                // If he is not, it means the change to apply is to add this user
                                if (!isInLoodle)
                                    LoodleDAO.addUser(loodleId, currentToken, token, finish);

                                // If the user is already associated, no need to do anything because
                                // our widget in oae will handle the access permission
                                return finish();
                            }
                        ], end);

                    }
                    // This user is not already registred in the loodle application
                    else {

                        async.waterfall([
                            // Get the user informations
                            async.apply(userAPI.getUser, ctx, userId),
                            // Registred the user in the loodle application
                            connect,
                            // Add the user to the loodle
                            async.apply(LoodleDAO.addUser, loodleId, currentToken)
                        ], end);

                    }
                });

            }, done);
        }
    ], callback);

};

/**
 * Add a schedule to the specified loodle
 *
 * @param 	{Context}   ctx       		Standard context object containing the current user and the current tenant
 * @param 	{String}   	contentId 		Content identifier
 * @param 	{Object}   	schedule  		Schedule object
 * @param 	{Function} 	callback  		Standard callback function
 */
exports.addSchedule = function (ctx, loodleId, schedule, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(TokenDAO.get, currentUser.id),
        async.apply(LoodleDAO.addSchedule, loodleId, schedule, currentUser.locale)
    ], callback);

};

/**
 * Delete a schedule to the specified loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	loodleId   		Loodle identifier
 * @param  {String}   	scheduleId 		Schedule identifier
 * @param  {Function} 	callback   		Standard callback function
 */
exports.deleteSchedule = function (ctx, loodleId, scheduleId, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(TokenDAO.get, currentUser.id),
        async.apply(LoodleDAO.deleteSchedule, loodleId, scheduleId)
    ], callback);

};

/**
 * Update the votes of a user in a loodle
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {Object}   	votes    		Vote object : schedule id as key, vote as value
 * @param  {Function} callback 			Standard callback function
 */
exports.updateVotes = function (ctx, votes, loodleId, callback) {

    var currentUser = ctx.user();

    TokenDAO.get(currentUser.id, function (err, token) {

        LoodleDAO.updateVotes(token, loodleId, votes, function (err) {
            if (err)
                return callback(err);

            return callback(err);

        });

    });

};

/**
 * Emit a notification saying that the loodle's schedules has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateScheduleNotification = function (ctx, contentId, callback) {

    var ContentAPI = require('oae-content');
    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err)
            return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_DOODLE_SCHEDULES, ctx, contentObj);
        return callback();
    });

};

/**
 * Emit a notification saying that the loodle's votes has been updated
 *
 * @param  {Context}   	ctx       		Standard context object containing the current user and the current tenant
 * @param  {String}   	contentId 		Content identifier
 * @param  {Function} 	callback  		Standard callback function
 */
exports.emitUpdateVoteNotification = function (ctx, contentId, callback) {

    var ContentAPI = require('oae-content');
    ContentDAO.Content.getContent(contentId, function(err, contentObj) {
        if (err)
            return callback(err);

        ContentAPI.emit(ContentConstants.events.EDITED_DOODLE_VOTES, ctx, contentObj);
        return callback();
    });

};

exports.getData = function (ctx, loodleId, callback) {

    var currentUser = ctx.user();

    async.waterfall([
        async.apply(TokenDAO.get, currentUser.id),
        async.apply(LoodleDAO.get, loodleId)
    ], callback);

};

// Private functions ============================================

/**
 * Get the token to communicate with the loodle application
 *
 * @param  {Object}   user     	User object
 * @param  {Function} callback 	Standard callback function
 */
function getToken (user, callback) {

    log().info('getToken');

    /**
     * Workflow
     * --> Test if the current user has a token already saved in db
     * --> If that's the case, get it
     * --> If not, call to connect function
     */

    TokenDAO.isInDb(user.id, function (err, isInDb) {
        if (err)
            return callback(err);

        if (isInDb)
            return TokenDAO.get(user.id, callback);

        return connect(user, callback);
    });

}

/**
 * Connect to the loodle application by creating
 * a miror account and saving the token to communicate
 * with the api
 *
 * @param  {Object}   user      User object
 * @param  {Function} callback 	Standard callback function
 */
function connect (user, callback) {

    log().info('connect');

    /**
     * Workflow
     * --> Create a miror user in the loodle application
     * --> Authenticate as this user to get a token
     * --> Save the token in db
     */

    UserDAO.createAccount(user, function (err) {
        if (err)
            return callback(err);

        TokenDAO.authenticate(user.email, function (err, token) {
            if (err)
                return callback(err);

            TokenDAO.save(user.id, token, function (err) {
                if (err)
                    return callback(err);

                return callback(null, token);
            });
        });
    });

}
