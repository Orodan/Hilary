var _ = require('underscore');
var assert = require('assert');
var temp = require('temp');
var async = require('async');

var Cassandra = require('oae-util/lib/cassandra');
var RestAPI = require('oae-rest');
var TestsUtil = require('oae-tests');
var TaskQueue = require('oae-util/lib/taskqueue');
var PreviewConstants = require('oae-preview-processor/lib/constants');

describe('Loodle update', function () {

    // Rest context that can be used every time we need to make a request as an anonymous user
    var anonymousRestContext = null;

    // Rest contexts that can be used every time we need to make a request as a tenant admin
    var camAdminRestContext = null;
    var gtAdminRestContext = null;

    // Rest context that can be used every time we need to make a request as a global admin
    var globalAdminRestContext = null;

    /**
     * Create a number of users that will be used inside of a test
     * @param  {Function(contexts)}  callback           Standard callback function
     * @param  {Object}              callback.contexts  Object where the keys are identifiers for the created users and the values are an
     *                                                  object with a user key containing the user object for the created user and a restContext key
     *                                                  containing the REST Context for that user
     */
    var setUpUsers = function(callback) {
        var contexts = {};
        var createUser = function(identifier, visibility, displayName) {
            var userId = TestsUtil.generateTestUserId(identifier);
            var email = TestsUtil.generateTestEmailAddress(null, global.oaeTests.tenants.cam.emailDomain);
            RestAPI.User.createUser(camAdminRestContext, userId, 'password', displayName, email, {'visibility' : visibility}, function(err, createdUser) {
                if (err) {
                    assert.fail('Could not create test user');
                }
                contexts[identifier] = {
                    'user': createdUser,
                    'restContext': TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host, userId, 'password')
                };
                if (_.keys(contexts).length === 7) {
                    callback(contexts);
                }
            });
        };

        createUser('nicolaas', 'public', 'Nicolaas Matthijs');
        createUser('simon', 'loggedin', 'Simon Gaeremynck');
        createUser('bert', 'private', 'Bert Pareyn');
        createUser('branden', 'private', 'Branden Visser');
        createUser('anthony', 'public', 'Anthony Whyte');
        createUser('stuart', 'public', 'Stuart Freeman');
        createUser('ian', 'public', 'Ian Dolphin');
    };

    /**
     * Function that will fill up the anonymous and tenant admin REST context
     */
    before(function (callback) {
        // Fill up anonymous rest context
        anonymousRestContext = TestsUtil.createTenantRestContext(global.oaeTests.tenants.cam.host);

        // Fill up tenant admin rest contexts
        camAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.cam.host);
        gtAdminRestContext = TestsUtil.createTenantAdminRestContext(global.oaeTests.tenants.gt.host);

        // Fill up global admin rest context
        globalAdminRestContext = TestsUtil.createGlobalAdminRestContext();

        // Log in the tenant admin so his cookie jar is set up appropriately. This is because TestsUtil.generateTestUsers
        // will concurrently try and create users, which causes race conditions when trying to authenticate the rest
        // context.
        RestAPI.User.getMe(camAdminRestContext, function(err, meObj) {
            assert.ok(!err);

            // Unbind the current handler, if any
            TaskQueue.unbind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, function(err) {
                assert.ok(!err);

                /*!
                 * Task handler that will just drain the queue.
                 *
                 * @see MQ#bind
                 */
                var _handleTaskDrain = function(data, mqCallback) {
                    // Simply callback, which acknowledges the message without doing anything.
                    mqCallback();
                };

                // Drain the queue
                TaskQueue.bind(PreviewConstants.MQ.TASK_REGENERATE_PREVIEWS, _handleTaskDrain, null, function(err) {
                    assert.ok(!err);
                    callback();
                });
            });
        });
    });

    /**
     * Function that will clean up any files that we have lingering around.
     */
    after(function () {
        temp.cleanup();
    });

    describe('add another user to a loodle', function () {

        it('should give the user an access to the loodle', function (callback) {

            setUpUsers(function (contexts) {
                // Create the loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Add an user
                    var changes = {};
                    changes[contexts['simon'].user.id] = 'manager';
                    RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                        if (err) return callback(err);

                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                            assert.equal(err, null);
                            assert.equal(content.isManager, true);

                            return callback();
                        });
                    });
                });
            });

        });

        it('should add the user as a participant in the loodle', function (callback) {

            setUpUsers(function (contexts) {
                // Create the loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Add an user
                    var changes = {};
                    changes[contexts['simon'].user.id] = 'manager';
                    RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                        if (err) return callback(err);

                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                            assert.equal(err, null);

                            var users = _.pluck(content.loodleData.users, 'first_name');
                            assert.equal(users.length, 2);
                            assert.equal(_.contains(users, 'Branden'), true);
                            assert.equal(_.contains(users, 'Simon'), true);

                            return callback();
                        });
                    });
                });
            });

        });

        it('should handle the case where the user already had another access to the loodle through a group : he/she is not added again as participant in the loodle and keeps/gains the "higher" role according to his/her access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [], [contexts['simon'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create the loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add an user
                        var changes = {};
                        changes[contexts['simon'].user.id] = 'viewer';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });

                });

            });

        });

        it('should handle the case where the user already had another access to this loodle through a folder : he/she is added as participantant in the loodle and have his/her role updated', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create the loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Test', 'private', [], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Add an user
                        var changes = {};
                        changes[contexts['simon'].user.id] = 'manager';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });

                });

            });

        });

    });

    describe('add another group to a loodle', function () {

        it('should give the group an access to the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add a group
                        var changes = {};
                        changes[group.id] = 'manager';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            async.parallel({
                                getBySimon: function (done) {
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, true);
                                        return done();
                                    });
                                },
                                getByStuart: function (done) {
                                    RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, true);
                                        return done();
                                    });
                                }
                            }, callback);
                        });
                    });
                });

            });

        });

        it('should add all the users of the group as participants in the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add a group
                        var changes = {};
                        changes[group.id] = 'manager';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 3);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);
                                assert.equal(_.contains(users, 'Stuart'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group has other groups as members : all the users must have an access to the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe 1', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe 2', 'Un groupe de test', 'private', 'no', [contexts['ian'].user.id], [contexts['anthony'].user.id], function (err, group2) {
                        if (err) return callback(err);

                        // Add the second group as a member of the first one
                        var changes = {};
                        changes[group2.id] = 'manager';
                        RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group1.id, changes, function (err, result) {
                            if (err) return callback(err);

                            // Create a loodle
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                                if (err) return callback(err);

                                // Add the first group
                                var changes = {};
                                changes[group1.id] = 'manager';
                                RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                    if (err) return callback(err);

                                    async.parallel({
                                        getBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);
                                                return done();
                                            });
                                        },
                                        getByStuart: function (done) {
                                            RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);
                                                return done();
                                            });
                                        },
                                        getByIan: function (done) {
                                            RestAPI.Content.getContent(contexts['ian'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);
                                                return done();
                                            });
                                        },
                                        getByAnthony: function (done) {
                                            RestAPI.Content.getContent(contexts['anthony'].restContext, data.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, true);
                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the added group has other groups as members : all the users must be added as participants', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe 1', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe 2', 'Un groupe de test', 'private', 'no', [contexts['ian'].user.id], [contexts['anthony'].user.id], function (err, group2) {
                        if (err) return callback(err);

                        // Add the second group as a member of the first one
                        var changes = {};
                        changes[group2.id] = 'manager';
                        RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group1.id, changes, function (err, result) {
                            if (err) return callback(err);

                            // Create a loodle
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                                if (err) return callback(err);

                                // Add the first group
                                var changes = {};
                                changes[group1.id] = 'manager';
                                RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                    if (err) return callback(err);

                                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 5);
                                        assert.equal(_.contains(users, 'Branden'), true);
                                        assert.equal(_.contains(users, 'Simon'), true);
                                        assert.equal(_.contains(users, 'Stuart'), true);
                                        assert.equal(_.contains(users, 'Ian'), true);
                                        assert.equal(_.contains(users, 'Anthony'), true);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one group user has another access to the loodle thanks to being personaly invited or through another group : he/she is not added again as participant and keeps/gains the "higher" role he/she can have', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add an user
                        var changes = {};
                        changes[contexts['simon'].user.id] = 'viewer';
                        RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            // Add a group
                            changes = {};
                            changes[group.id] = 'manager';
                            RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, true);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one group user has another access to the loodle through another folder : he/she is added again as a participant and have his/her access updated', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'Un groupe de test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Add an user
                            var changes = {};
                            changes[contexts['simon'].user.id] = 'manager';
                            RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                // Add a group
                                changes = {};
                                changes[group.id] = 'manager';
                                RestAPI.Content.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                    if (err) return callback(err);

                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, true);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 2);
                                        assert.equal(_.contains(users, 'Branden'), true);
                                        assert.equal(_.contains(users, 'Simon'), true);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('add a loodle to a folder', function () {

        it('should give an access in read only mode to all the users of the folder to the loodle ', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add the loodle to the folder
                        RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                            if (err) return callback (err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);

                                return callback();
                            });
                        });
                    })
                });

            });

        });

        it('should not add the folder members as participants of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Add the loodle to the folder
                        RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                            if (err) return callback (err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 1);
                                assert.equal(_.contains(users, 'Branden'), true);

                                return callback();
                            });
                        });
                    })
                });

            });

        });

        it('should handle the case where a group is a folder member : all group users must have access in read only mode to the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe de test', 'test', 'private', 'no', [contexts['stuart'].user.id], [contexts['ian'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with a group as a member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id, group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [], function (err, data) {
                            if (err) return callback(err);

                            // Add the loodle to the folder
                            RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                                if (err) return callback (err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);

                                    return callback();
                                });
                            });
                        })
                    });
                });

            });

        });

        it('should handle the case where a group is a folder member and one group user has another access to the loodle thanks to being invited personaly or through another group : he/she keeps being a participant in the loodle and keeps the role he/she had', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe de test', 'test', 'private', 'no', [contexts['stuart'].user.id], [contexts['ian'].user.id], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with a group as a member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id, group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [contexts['stuart'].user.id], [], [], function (err, data) {
                            if (err) return callback(err);

                            // Add the loodle to the folder
                            RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                                if (err) return callback (err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Stuart'), true);

                                    return callback();
                                });
                            });
                        })
                    });
                });

            });

        });

        it('should handle the case where a group is a folder member and one group user has another access to the loodle through another folder : he/she keeps only having a read only access to the loodle without being added as participant', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier 1', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder1) {
                    if (err) return callback(err);

                    // Create a second folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super doosier 2', 'Un dossier de test', 'private', [contexts['simon'].user.id], [], function (err, folder2) {
                        if (err) return callback(err);

                        // Create a loodle within the first folder
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [], [], [folder1.id], function (err, data) {
                            if (err) return callback(err);

                            // Add the loodle to the second folder
                            RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder2.id, [data.id], function (err) {
                                if (err) return callback(err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    if (err) return callback(err);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where a group is a folder member and one of its group member is also a group which has another access to the loodle thanks to being invited personaly or through another group : the concerned group users keep being participants and they keep the role they had', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe de test 1', 'test', 'private', 'no', [contexts['stuart'].user.id], [contexts['ian'].user.id], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group with the first group as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe de test 2', 'test', 'private', 'no', [contexts['stuart'].user.id, group1.id], [], function (err, group2) {
                        if (err) return callback(err);

                        // Create a folder with the second group as a member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier', 'Un dossier de test', 'private', [contexts['simon'].user.id, group2.id], [], function (err, folder) {
                            if (err) return callback(err);

                            // Create a loodle
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'Un loodle de test', 'private', [group1.id], [], [], function (err, data) {
                                if (err) return callback(err);

                                // Add the loodle to the folder
                                RestAPI.Folders.addContentItemsToFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                                    if (err) return callback (err);

                                    RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 3);
                                        assert.equal(_.contains(users, 'Branden'), true);
                                        assert.equal(_.contains(users, 'Stuart'), true);
                                        assert.equal(_.contains(users, 'Ian'), true);

                                        return callback();
                                    });
                                });
                            })
                        });
                    });
                });

            });

        });

    });

    describe('remove an user from a loodle', function () {

        it('should stop the access to the loodle for this user', function (callback) {

            setUpUsers(function (contexts) {

                // Create a loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [contexts['simon'].user.id], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Remove an user from a loodle
                    var changes = {};
                    changes[contexts['simon'].user.id] = false;
                    RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                        if (err) return callback(err);

                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                            assert.notEqual(err, null);
                            assert.equal(err.code, 401);
                            assert.equal(err.msg, 'The current user does not have access to this resource');

                            return callback();
                        });
                    });
                });

            });

        });

        it('should remove the user as a participant of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a loodle
                RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [contexts['simon'].user.id], [], [], function (err, data) {
                    if (err) return callback(err);

                    // Remove an user from a loodle
                    var changes = {};
                    changes[contexts['simon'].user.id] = false;
                    RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                        if (err) return callback(err);

                        RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                            assert.equal(err, null);

                            var users = _.pluck(content.loodleData.users, 'first_name');
                            assert.equal(users.length, 1);
                            assert.equal(_.contains(users, 'Branden'), true);

                            return callback();
                        });
                    });
                });

            });

        });

        it('should handle the case where the user has another access to the loodle thanks to a group : the user keeps an updated access to the loodle according to the access of the group and keeps being a participant in the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe', 'un groupe de test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [contexts['simon'].user.id], [group.id], [], function (err, data) {
                        if (err) return callback(err);

                        // Remove an user from a loodle
                        var changes = {};
                        changes[contexts['simon'].user.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, false);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });
                });
            });

        });

        it('should handle the case where the user has another access to the loodle thanks to a folder : the user keep an access in read only mode to the loodle but is removed as participant', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier de test', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [contexts['simon'].user.id], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Remove an user from a loodle
                        var changes = {};
                        changes[contexts['simon'].user.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, false);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 1);
                                assert.equal(_.contains(users, 'Branden'), true);

                                return callback();
                            });
                        });
                    });
                });
            });

        });

    });

    describe('remove a group from a loodle', function () {

        it('should stop the access for the group', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Remove the group from the loodle
                        var changes = {};
                        changes[group.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err) {
                                assert.notEqual(err, null);
                                assert.equal(err.code, 401);
                                assert.equal(err.msg, 'The current user does not have access to this resource');

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should remove the group users as participants of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle', 'test', 'private', [group.id], [], [], function (err, data) {
                        if (err) return callback(err);

                        // Remove the group from the loodle
                        var changes = {};
                        changes[group.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 1);
                                assert.equal(_.contains(users, 'Branden'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group has another access to the loodle through another group : the group members keep being participants and have the same role as their group', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super group de test 1', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test 2', 'test', 'private', 'no', [contexts['stuart'].user.id], [group1.id], function (err, group2) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle de test', 'test', 'private', [group1.id], [group2.id], [], function (err, data) {
                            if (err) return callback(err);

                            // Remove the first group from the loodle
                            var changes = {};
                            changes[group1.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 3);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);
                                    assert.equal(_.contains(users, 'Stuart'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the group has another access to the loodle through a folder : the group members are removed as participants in the loodle and have a read only access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super group test', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon super dossier de test', 'test', 'private', [group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle de test', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the group from the loodle
                            var changes = {};
                            changes[group.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one member of the removed group is another group : all groups must lose their access to the loodle and all groups users must be removed as participants of the loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test 1', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group with the first group as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test 2', 'test', 'private', 'no', [group1.id], [], function (err, group2) {
                        if (err) return callback(err);

                        // Create a loodle with the second group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle de test', 'test', 'private', [group2.id], [], [], function (err, data) {
                            if (err) return callback(err);

                            // Remove the second group from the loodle
                            var changes = {};
                            changes[group2.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                async.parallel({
                                    getBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                            assert.notEqual(err, null);
                                            assert.equal(err.code, 401);
                                            assert.equal(err.msg, 'The current user does not have access to this resource');

                                            return done();
                                        });
                                    },
                                    getByBranden: function (done) {
                                        RestAPI.Content.getContent(contexts['branden'].restContext, data.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 1);
                                            assert.equal(_.contains(users, 'Branden'), true);

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one user of the removed group has another access to the loodle thanks to being invited personaly or through another group : the user keeps an access to the loodle and keeps being a participant', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon super groupe de test', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a loodle with the group and one group member as members
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon super loodle de test', 'test', 'private', [group.id], [contexts['simon'].user.id], [], function (err, data) {
                        if (err) return callback(err);

                        // Remove the group from the loodle
                        var changes = {};
                        changes[group.id] = false;
                        RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                            if (err) return callback(err);

                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, false);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one user of the removed group has another access to the loodle through a folder : the user is removed as a participant in the loodle and have a read only access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder with one user
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                    if (err) return callback(err);

                    // Create one group with the same user in it
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder and with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the group from the loodle
                            var changes = {};
                            changes[group.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the common user between the folder and the group has been removed as participant and have a read only access
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one member of the removed group is another group which has another access to the loodle thanks to being invited personaly or through another group : the group users keep an access to the loodle and keeps being participants', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe 1', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group1) {
                    if (err) return callback(err);

                    // Create a second group with the first group as member
                    RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe 2', 'test', 'private', 'no', [group1.id], [], function (err, group2) {
                        if (err) return callback(err);

                        // Create a loodle with the first and second group as members
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group2.id], [group1.id], [], function (err, data) {
                            if (err) return callback(err);

                            // Remove the second group from the loodle
                            var changes = {};
                            changes[group2.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the first group users have still access to the loodle and are still displayed as participants
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where one member of the removed group is another group which has another access to the loodle through a folder : the group users are removed as participants in the loodle and have a read only access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder and with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the group from the loodle
                            var changes = {};
                            changes[group.id] = false;
                            RestAPI.Loodles.updateMembers(contexts['branden'].restContext, data.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if the group users have still access to the loodle in read only mode and have been removed as participants
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('remove a loodle from a folder', function () {

        it('should stop the access for all the folder members', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Remove the loodle from the folder
                        RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                            if (err) return callback(err);

                            // Check that the the access to the loodle has been removed for all the folder users
                            async.parallel({
                                getBySimon: function (done) {
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err) {
                                        assert.notEqual(err, null);
                                        assert.equal(err.code, 401);
                                        assert.equal(err.msg, 'The current user does not have access to this resource');

                                        return done();
                                    });
                                },
                                getByStuart: function (done) {
                                    RestAPI.Content.getContent(contexts['stuart'].restContext, data.id, function (err) {
                                        assert.notEqual(err, null);
                                        assert.equal(err.code, 401);
                                        assert.equal(err.msg, 'The current user does not have access to this resource');

                                        return done();
                                    });
                                }
                            }, callback);
                        });
                    });
                });

            });

        });

        it('should handle the case where an user of the folder has another access to the loodle thanks to being personaly invited or through another group : the user is still a participant in the loodle and keeps the same access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, folder) {
                    if (err) return callback(err);

                    // Create a loodle inside of the folder
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [contexts['simon'].user.id], [], [folder.id], function (err, data) {
                        if (err) return callback(err);

                        // Remove the loodle from the folder
                        RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                            if (err) return callback(err);

                            // Check if the user that had two access to the loodle is still a participant and still has access
                            RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                assert.equal(err, null);
                                assert.equal(content.isManager, true);

                                var users = _.pluck(content.loodleData.users, 'first_name');
                                assert.equal(users.length, 2);
                                assert.equal(_.contains(users, 'Branden'), true);
                                assert.equal(_.contains(users, 'Simon'), true);

                                return callback();
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where an user of the folder has another access to the loodle through another folder : the user is still not a participant in the loodle and keeps the same read only access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a first folder
                RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 1', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, folder1) {
                    if (err) return callback(err);

                    // Create a second folder
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 2', 'test', 'private', [contexts['simon'].user.id], [contexts['stuart'].user.id], function (err, folder2) {
                        if (err) return callback(err);

                        // Create a loodle inside of the two folders
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder1.id, folder2.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the loodle from the first folder
                            RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder1.id, [data.id], function (err) {
                                if (err) return callback(err);

                                // Check if the user that had two access to the loodle is still a participant and still has access
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, false);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 1);
                                    assert.equal(_.contains(users, 'Branden'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the folder has a group as a member which has another access to the loodle thanks to being personaly invited or through another group : the group users are still participants in the loodle and keep the same access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon group', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [group.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a loodle inside of the folder and with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [group.id], [], [folder.id], function (err, data) {
                            if (err) return callback(err);

                            // Remove the loodle from the folder
                            RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder.id, [data.id], function (err) {
                                if (err) return callback(err);

                                // Check if the user that had two access to the loodle is still a participant and still has access
                                RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                    assert.equal(err, null);
                                    assert.equal(content.isManager, true);

                                    var users = _.pluck(content.loodleData.users, 'first_name');
                                    assert.equal(users.length, 2);
                                    assert.equal(_.contains(users, 'Branden'), true);
                                    assert.equal(_.contains(users, 'Simon'), true);

                                    return callback();
                                });
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the folder has a group as a member which has another access to the loodle through another folder : the group users are still not participants in the loodle and keep the same access', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first folder with the group as member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 1', 'test', 'private', [group.id], [], function (err, folder1) {
                        if (err) return callback(err);

                        // Create a second folder with the group as member
                        RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier 2', 'test', 'private', [group.id], [], function (err, folder2) {
                            if (err) return callback(err);

                            // Create a loodle inside of the two folders
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle', 'test', 'private', [], [], [folder1.id, folder2.id], function (err, data) {
                                if (err) return callback(err);

                                // Remove the loodle from the first folder
                                RestAPI.Folders.removeContentItemsFromFolder(contexts['branden'].restContext, folder1.id, [data.id], function (err) {
                                    if (err) return callback(err);

                                    // Check if the group users still have an read only access to the loodle
                                    RestAPI.Content.getContent(contexts['simon'].restContext, data.id, function (err, content) {
                                        assert.equal(err, null);
                                        assert.equal(content.isManager, false);

                                        var users = _.pluck(content.loodleData.users, 'first_name');
                                        assert.equal(users.length, 1);
                                        assert.equal(_.contains(users, 'Branden'), true);

                                        return callback();
                                    });
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('remove a user from a group', function () {

        it('should remove the access to the loodles of the group from the user', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first loodle with the group as member
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [], [], function (err, data1) {
                        if (err) return callback(err);

                        // Create a second loodle with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [group.id], [], [], function (err, data2) {
                            if (err) return callback(err);

                            // Remove an user from the group
                            var changes = {};
                            changes[contexts['simon'].user.id] = false;
                            RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check the user has no longer access to any of the group loodles
                                async.parallel({
                                    getFirstLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                            assert.notEqual(err, null);
                                            assert.equal(err.code, 401);
                                            assert.equal(err.msg, 'The current user does not have access to this resource');

                                            return done();
                                        });
                                    },
                                    getSecondLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                            assert.notEqual(err, null);
                                            assert.equal(err.code, 401);
                                            assert.equal(err.msg, 'The current user does not have access to this resource');

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should remove the user as participant of all the loodles of the group', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first loodle with the group as member
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [], [], function (err, data1) {
                        if (err) return callback(err);

                        // Create a second loodle with the group as member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [group.id], [], [], function (err, data2) {
                            if (err) return callback(err);

                            // Remove an user from the group
                            var changes = {};
                            changes[contexts['simon'].user.id] = false;
                            RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check the user is no longer a participant to any of the group loodles
                                async.parallel({
                                    getBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['branden'].restContext, data1.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 1);
                                            assert.equal(_.contains(users, 'Branden'), true);

                                            return done();
                                        });
                                    },
                                    getByBranden: function (done) {
                                        RestAPI.Content.getContent(contexts['branden'].restContext, data2.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, true);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 1);
                                            assert.equal(_.contains(users, 'Branden'), true);

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the user has another access to one or many loodles of the group thanks to being personaly invited or through another group : the user has his/her role updated but keeps an access to these loodles and keeps being a participant', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a first loodle with the group as member and one group member explicitly invited
                    RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [contexts['simon'].user.id], [], function (err, data1) {
                        if (err) return callback(err);

                        // Create a second loodle with the group as member and one group member explicitly invited
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [group.id], [contexts['simon'].user.id], [], function (err, data2) {
                            if (err) return callback(err);

                            // Remove the group member explicitly invited from the group
                            var changes = {};
                            changes[contexts['simon'].user.id] = false;
                            RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                if (err) return callback(err);

                                // Check if he/she keeps his/her access, has the same role as the group and is still a participant in the loodle
                                async.series({
                                    getFirstLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, false);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 2);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);

                                            return done();
                                        });
                                    },
                                    getSecondLoodleBySimon: function (done) {
                                        RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                            assert.equal(err, null);
                                            assert.equal(content.isManager, false);

                                            var users = _.pluck(content.loodleData.users, 'first_name');
                                            assert.equal(users.length, 2);
                                            assert.equal(_.contains(users, 'Branden'), true);
                                            assert.equal(_.contains(users, 'Simon'), true);

                                            return done();
                                        });
                                    }
                                }, callback);
                            });
                        });
                    });
                });

            });

        });

        it('should handle the case where the user has another access to one or many loodles through a folder : the user keeps an access in read only mode but is no longer a participant in this loodle', function (callback) {

            setUpUsers(function (contexts) {

                // Create a group
                RestAPI.Group.createGroup(contexts['branden'].restContext, 'Mon groupe', 'test', 'private', 'no', [contexts['simon'].user.id], [], function (err, group) {
                    if (err) return callback(err);

                    // Create a folder with one group member
                    RestAPI.Folders.createFolder(contexts['branden'].restContext, 'Mon dossier', 'test', 'private', [contexts['simon'].user.id], [], function (err, folder) {
                        if (err) return callback(err);

                        // Create a first loodle inside of the folder with the group as a member
                        RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 1', 'test', 'private', [group.id], [], [folder.id], function (err, data1) {
                            if (err) return callback(err);

                            // Create a second loodle inside of the folder with the group as a member
                            RestAPI.Loodles.createLoodle(contexts['branden'].restContext, 'Mon loodle 2', 'test', 'private', [group.id], [], [folder.id], function (err, data2) {
                                if (err) return callback(err);

                                // Remove the user from the group
                                var changes = {};
                                changes[contexts['simon'].user.id] = false;
                                RestAPI.Group.setGroupMembers(contexts['branden'].restContext, group.id, changes, function (err) {
                                    if (err) return callback(err);

                                    // Check if the user only has a read only access and is no longer a participant in a all the loodles of the group
                                    async.series({
                                        getFirstLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data1.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 1);
                                                assert.equal(_.contains(users, 'Branden'), true);

                                                return done();
                                            });
                                        },
                                        getSecondLoodleBySimon: function (done) {
                                            RestAPI.Content.getContent(contexts['simon'].restContext, data2.id, function (err, content) {
                                                assert.equal(err, null);
                                                assert.equal(content.isManager, false);

                                                var users = _.pluck(content.loodleData.users, 'first_name');
                                                assert.equal(users.length, 1);
                                                assert.equal(_.contains(users, 'Branden'), true);

                                                return done();
                                            });
                                        }
                                    }, callback);
                                });
                            });
                        });
                    });
                });

            });

        });

    });

    describe('remove a group B from a group A', function () {

        it('should remove the access of all the loodles of group A from group B');

        it('should remove all the members of group B as participants of all the loodles of group A');

        it('should handle the case where group B has another access to one or many loodles of group A thanks to being personaly invited or through another group : group B keeps an access to these loodles with an updated role according to its access and the users of group B are still participants');

        it('should handle the case where group B has another access to one or many loodles of group A through another folder : group B members keep an access in read only mode but are no longer participants to these loodles');

        it('should handle the case where group B has a user who has another access to one or many loodles of group A thanks to being personaly invited or through another group : the user keeps an access with an updated role according to its access and is still a participant of these loodles');

        it('should handle the case where group B has a user who has another access to one or many loodles of group A through another folder : the user keeps an access in read only mode but is no longer a participant to these loodles');

        it('should handle the case where group B has another group as a member which has another access to one or many loodles of group A thanks to being personaly invited or through another group : the group users keep an access with an updated role according to their access and are still participants of these loodles');

        it('should handle the case where group B has another group as a member which has another access to one or many loodles of group A through another folder : the group users keep an access in read only mode but are no longer a participant to these loodles');

    });

    describe('remove an user from a folder', function () {

        it('should remove the access to the loodles of the folder for the user');

        it('should handle the case where the user has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the user keeps the same access and is still a participant of these loodles');

        it('should handle the case where the user has another access to one or many loodles of the folder through another folder : the user keeps the same access and is still not a participant of these loodles');

    });

    describe('remove a group from a folder', function () {

        it('should remove the access to the loodles of the folder for the group');

        it('should handle the case where the removed group has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the group users keep the same access are still participants of these loodles');

        it('should handle the case where the removed group has another access to one or many loodles of the folder through another folder : the group users keep the same access are still not participants of these loodles');

        it('should handle the case where the removed group has an user who has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the user keeps the same access and is still a participant in these loodles');

        it('should handle the case where the removed group has an user who has another access to one or many loodles of the folder through another folder : the user keeps the same access and is still not a participant in these loodles');

        it('should handle the case where the removed group has another group as member which has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the group users keep the same access and are still participants in these loodles');

        it('should handle the case where the removed group has another group as member which has another access to one or many loodles of the folder through another folder : the group users keep the same access and are still not participants in these loodles');

    });

    describe('add another user to a group', function () {

        it('should give an access to all the loodles of the group to the new user');

        it('should add the user as a participant to all the loodles of the group');

        it('should handle the case where the added user already has another acces to one or many loodles of the group thanks to being personaly invited or through another group : the user is not added again as participant to these loodles and have an updated role according to his/her access');

        it('should handle the case where the added user already has another acces to one or many loodles of the group through another folder : the user is added as participant to these loodles and get the same access as the group');

    });

    describe('add another group B to a group A', function () {

        it('should give an access to all the loodles of group A to group B');

        it('should add as participants all the users of group B in all the loodles of group A');

        it('should handle the case where the group B has another access to one or many loodles of group A thanks to being personaly invited or through another group : the group users are not added again as participants in these loodles and keep/gain the "higher" role according to their access');

        it('should handle the case where the group B has another access to one or many loodles of group A through another folder : the group users are added as participants and get an access in these loodles');

        it('should handle the case where the group B has a user who has another access to one or many loodles of group A thanks to being personaly invited or through another group : the user is not added again as participant in these loodles and keeps/gains the "higher" role according to their access');

        it('should handle the case where the group B has a user who has another access to one or many loodles of group A through another folder : the user is added as participant in these loodles and get an access');

        it('should handle the case where the group B has another group as member which has another access to one or many loodles of group A thanks to being personaly invited or through another group : the group users are not added again as participants in these loodles and keep/gain the "higher" role according to their access');

        it('should handle the case where the group B has another group as member which has another access to one or many loodles of group A through another folder : the group get an access and the group users are added as participants in these loodles');

    });

    describe('add another user to a folder', function () {

        it('should give an access to all the loodles of the folder to the new user');

        it('should not add the user as participants in any of the loodles inside of the folder');

        it('should handle the case where the added user already has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the user is still a participant in these loodles and keeps the same role');

        it('should handle the case where the added user already has another access to one or many loodles of the folder through another folder : the user is still not added as participant in these loodles and keeps the same read only access');

    });

    describe('add another group to a fodler', function () {

        it('should give an access to all the loodles of the folder to the new group');

        it('should not add the group users as participants in any of the loodles inside of the folder');

        it('should handle the case where the added group already has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the group users are still participants in these loodles and keep the same role');

        it('should handle the case where the added group already has another access to one or many loodles of the folder through another folder : the group users are still not added as participants in these loodles and keep the same role');

        it('should handle the case where the added group has an user who already has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the user is still a participant in these loodles and keep the same role');

        it('should handle the case where the added group has an user who already has another access to one or many loodles of the folder through another folder : the user is still not added as a participant in these loodles and keep the same role');

        it('should handle the case where the added group has another group as a member which already has another access to one or many loodles of the folder thanks to being personaly invited or through another group : the group users are still participants in these loodles and keep the same role');

        it('should handle the case where the added group has another group as a member which already has another access to one or many loodles of the folder through another folder : the group users are still not added as participants in these loodles and keep the same role');

    });

    describe('update the role of an user', function () {

        it('should correctly update the role of the user for the loodle');

        it('should handle the case where the user has another access to the loodle through a group : the user keeps/gains the "higher" role');

        it('should handle the case where the user has another access to the loodle through a folder : the user role is still updated');

    });

    describe('update the role of a group', function () {

        it('should correctly update the role of all the group users');

        it('should handle the case where the group as another group as a member : all users must have their role updated');

        it('should handle the case where the group has another access to the loodle through another group : the group keeps/gains the "higher" role');

        it('should handle the case where the group has another access to the loodle through another folder : the group role is still updated');

        it('should handle the case where the group has an user with another access to the loodle through another group : the user keeps/gains the "higher" role');

        it('should handle the case where the group has an user with another access to the loodle through another folder : the user role is still updated');

    });

    describe('add a schedule to a loodle', function () {

        it('should add correctly the schedule to the loodle');

        it('should create default votes about this schedule for all the participants of the loodle');

        it('should send a notification for all the participants of the loodle');

    });

    describe('delete a schedule from a loodle', function () {

        it('should delete correctly the schedule from the loodle');

        it('should delete all the votes associated with the schedule');

    });

    describe('edit the votes of a loodle', function () {

        it('should correctly edit the votes of the loodle');

        it('should send a notification to all the administrators of the loodle');

    });

});
